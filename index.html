<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Corine ‚Äî Layer, Palette & Presenter</title>

<link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css">
<script src="https://js.arcgis.com/4.33/"></script>

<!-- TopoJSON client -->
<script type="module">
  import * as topojson from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";
  window.topojsonClient = topojson;
</script>

<style>
  :root{
    --r:12px; --shadow:0 6px 18px rgba(0,0,0,.22);
    --btn:#f4f4f5; --btnh:#ececee; --muted:#666;
  }
  html,body,#viewDiv{height:100%;margin:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #viewDiv{position:absolute;inset:0}

  /* Canvas di MapView: mai nero di default */
  .esri-view .esri-view-surface{ background-color:transparent; }

  /* pannello sinistro */
  #panel{
    position:absolute;top:12px;left:12px;z-index:30;width:420px;max-height:88vh;overflow:auto;
    background:#fff;border-radius:var(--r);box-shadow:var(--shadow);padding:10px
  }
  #panel.collapsed{display:none}
  #panelToggle{
    position:absolute;top:12px;left:12px;z-index:31;width:40px;height:40px;border:none;border-radius:10px;
    background:var(--btn);box-shadow:var(--shadow);cursor:pointer;font-size:18px
  }

  .row{display:flex;gap:8px;align-items:center;margin:.45rem 0}
  .grow{flex:1}
  .muted{color:var(--muted);font-size:12px}
  button,select,input{font:inherit}
  .chip{padding:4px 8px;border-radius:999px;background:var(--btn);border:1px solid #e5e5e5}
  .chip:hover{background:var(--btnh)}

  /* lista layer server compatta */
  #serverWrap{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:6px}
  .srv{display:flex;align-items:center;gap:6px;border:1px solid #e7e7e7;border-radius:9px;padding:6px;background:#fff}
  .srv label{font-size:13px;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  /* cards layer */
  .card{border:1px solid #ececec;border-radius:10px;padding:8px;background:#fafafa;margin-top:8px}
  .card h5{margin:0 0 6px 0;font-size:13px}
  .swatch{display:inline-block;width:16px;height:16px;border:1px solid #ccc;margin-left:2px;border-radius:3px}

  /* palette sidebar (draggable + resizable + scroll interno) */
  #palSidebar{
    position:absolute;top:12px;right:12px;z-index:30;
    display:flex;flex-direction:column;
    width:min(18vw,360px);min-width:280px;max-height:calc(100vh - 120px);
    resize:both;overflow:hidden;
    background:#fff;border-radius:var(--r);box-shadow:var(--shadow);padding:10px;
  }
  #palSidebar.collapsed{display:none}
  #palToggle{
    position:absolute;top:110px;right:12px;z-index:31;height:40px;padding:0 10px;border:none;border-radius:10px;
    background:var(--btn);box-shadow:var(--shadow);cursor:pointer
  }
  #palHeader{cursor:move;user-select:none;display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
  #palGallery{flex:1;overflow:auto}

  #palGallery .pal{border:1px solid #eee;border-radius:10px;padding:8px;margin-bottom:8px;background:#fff;cursor:pointer}
  .pal-top{display:flex;justify-content:space-between;align-items:center;font-weight:600;font-size:11px}
  .pal-links a{font-size:14px;text-decoration:none;opacity:.85;margin-left:6px}
  .pal-links a:hover{opacity:1}
  .sw10{display:grid;grid-template-columns:repeat(10,1fr);gap:4px;margin-top:6px}
  .sw{height:16px;border-radius:3px;border:1px solid #ddd}

  /* dock centrale: sfondo/slideshow/shuffle/export */
  .dockC{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;z-index:40;display:flex;gap:8px}
  .pill{border:none;border-radius:999px;padding:10px 14px;background:var(--btn);box-shadow:var(--shadow);cursor:pointer}
  .pill:hover{background:var(--btnh)}

  /* margine per BasemapGallery in basso-destra */
  .esri-ui-bottom-right{margin:12px}

  @media (max-width:980px){
    #panel{width:92vw}
    #palSidebar{width:calc(100vw - 24px);left:12px;min-width:auto}
  }
</style>
</head>
<body>
  <div id="viewDiv"></div>

  <button id="panelToggle" title="Mostra/Nascondi pannello">‚ò∞</button>
  <button id="palToggle" title="Palette">üé® Palette</button>

  <div id="panel">
    <div class="row" style="justify-content:space-between">
      <strong style="margin-left:40px">Layer & file</strong>
      <span class="muted">legend per-layer ‚Ä¢ palette per-layer</span>
    </div>

    <h4 style="margin:.3rem 0 .5rem 0;font-size:14px">Layer sul server</h4>
    <div id="serverWrap"></div>
    <div class="row">
      <button id="btnLoadSelected" class="chip">Carica selezionati</button>
      <button id="btnLoadAll" class="chip">Carica tutti</button>
      <span class="muted grow" style="text-align:right">oppure file locali‚Ä¶</span>
    </div>
    <div class="row">
      <input id="fileInput" class="grow" type="file" accept=".topojson,.geojson,.json" multiple>
    </div>

    <h4 style="margin-top:10px">Layer caricati</h4>
    <div id="layersWrap"></div>
  </div>

  <!-- Palette sidebar -->
  <div id="palSidebar" class="collapsed">
    <div id="palHeader">
      <h4 style="margin:0">Palette</h4>
      <button id="palClose" class="chip" title="Chiudi">‚úñ</button>
    </div>
    <div class="muted">clic per applicare</div>
    <div id="palGallery"></div>
  </div>

  <div class="dockC">
    <button id="btnDayNight" class="pill" title="Sfondo">üåì</button>
    <input id="bgColor" type="color" value="#111111" title="Colore sfondo" class="pill" style="width:48px;height:40px;padding:6px 8px">
    <button id="btnShow" class="pill" title="Slideshow on/off">üéûÔ∏è</button>
    <button id="btnShuffleGlobal" class="pill" title="Rimescola linkato">üé≤</button>
    <button id="btnExport" class="pill" title="Esporta PNG">PNG</button>
  </div>

<script>
/* ===== Config ===== */
const SERVER_ITEMS = [
  {label:"AVEIRO", path:"AVEIRO.topojson"},
  {label:"BEJA", path:"BEJA.topojson"},
  {label:"BRAGA", path:"BRAGA.topojson"},
  {label:"BRAGANCA", path:"BRAGANCA.topojson"},
  {label:"CASTELO BRANCO", path:"CASTELO_BRANCO.topojson"},
  {label:"COIMBRA", path:"COIMBRA.topojson"},
  {label:"EVORA", path:"EVORA.topojson"},
  {label:"FARO", path:"FARO.topojson"},
  {label:"GUARDA", path:"GUARDA.topojson"},
  {label:"LEIRIA", path:"LEIRIA.topojson"},
  {label:"LISBOA", path:"LISBOA.topojson"},
  {label:"LISBOA_BLOCOS", path:"lisboa_blocos.json"},
  {label:"PORTALEGRE", path:"PORTALEGRE.topojson"},
  {label:"PORTO", path:"PORTO.topojson"},
  {label:"SANTAREM", path:"SANTAREM.topojson"},
  {label:"SETUBAL", path:"SETUBAL.topojson"},
  {label:"VIANA DO CASTELO", path:"VIANA_DO_CASTELO.topojson"},
  {label:"VILA REAL", path:"VILA_REAL.topojson"},
  {label:"VISEU", path:"VISEU.topojson"}
];
const DEFAULT_PALETTE_URL = "./palette_from_tbw.json";

/* ===== State ===== */
let map, view;
let PALETTES = {}, PALETTE_NAMES = [];
const LAYERS = [];               // {layer,title,groupField,paletteName,opacity,override,visible,fields}
const NAME_TO_ENTRY = new Map();
const PALETTE_PERM = new Map();
let showTimer = null;
let bgMode = "map";
let SHUFFLE_TICK = 0;  // varia il seed a ogni shuffle

/* ===== ArcGIS ===== */
require([
  "esri/Map","esri/views/MapView","esri/layers/GeoJSONLayer",
  "esri/widgets/BasemapGallery","esri/widgets/Expand","esri/Basemap"
], function(EsriMap, MapView, GeoJSONLayer, BasemapGallery, Expand, Basemap){

  map = new EsriMap({ basemap:"gray-vector" });
  view = new MapView({ container:"viewDiv", map, center:[-8,39.5], zoom:7 });

  // Zoom in alto-destra
  view.ui.move("zoom","top-right");

  // BasemapGallery in basso-destra, dentro Expand (auto-hide)
  const gallery = new BasemapGallery({ view });
  const galleryExpand = new Expand({ view, content: gallery, expanded:false, expandIcon:"basemap", group:"br" });
  view.ui.add(galleryExpand, "bottom-right");
  gallery.watch("activeBasemap", () => { if (galleryExpand.expanded) galleryExpand.collapse(); });
  view.on("key-down", (e)=>{ if(e.key==="Escape" && galleryExpand.expanded) galleryExpand.collapse(); });

  // toggles pannelli
  document.getElementById("panelToggle").onclick = () => {
    document.getElementById("panel").classList.toggle("collapsed");
  };
  document.getElementById("palToggle").onclick = () => {
    document.getElementById("palSidebar").classList.toggle("collapsed");
  };

  // ===== Palette drag & close =====
  const palSidebar = document.getElementById("palSidebar");
  const palHeader  = document.getElementById("palHeader");
  const palClose   = document.getElementById("palClose");
  palClose.onclick = () => palSidebar.classList.add("collapsed");
  let dragging=false, offX=0, offY=0;
  palHeader.onmousedown = (ev)=>{
    dragging=true; offX=ev.clientX-palSidebar.offsetLeft; offY=ev.clientY-palSidebar.offsetTop;
    document.onmousemove = (e)=>{
      if(!dragging) return;
      const w = palSidebar.offsetWidth, h = palSidebar.offsetHeight;
      const maxX = window.innerWidth - 12 - w;
      const maxY = window.innerHeight - 12 - h;
      let nx = Math.min(Math.max(12, e.clientX-offX), maxX);
      let ny = Math.min(Math.max(12, e.clientY-offY), maxY);
      palSidebar.style.left = nx+"px";
      palSidebar.style.top  = ny+"px";
      palSidebar.style.right="auto"; palSidebar.style.bottom="auto";
      palSidebar.style.maxHeight = (window.innerHeight - ny - 24) + "px";
    };
    document.onmouseup = ()=>{ dragging=false; document.onmousemove=null; };
  };

  // export
  document.getElementById("btnExport").onclick = async function(){
    try{
      const shot = await view.takeScreenshot({ format:"png", quality:100 });
      const a = document.createElement("a");
      a.href = shot.dataUrl;
      a.download = "map_"+new Date().toISOString().replace(/[:.]/g,"-")+".png";
      a.click();
    }catch(e){ console.error(e); }
  };

  // ===== Sfondo: colora davvero il canvas WebGL =====
  function setCanvasBg(hex){
    const viewDiv = document.getElementById("viewDiv");
    if (viewDiv) viewDiv.style.backgroundColor = hex;
    const surf = view && view.container ? view.container.querySelector(".esri-view-surface") : null;
    if (surf) surf.style.backgroundColor = hex;
  }
  document.getElementById("btnDayNight").onclick = function(){
    if(bgMode==="map"){
      map.basemap = new Basemap({ baseLayers: [] });
      bgMode="blank";
      setCanvasBg(document.getElementById("bgColor").value);
    }else{
      map.basemap = "gray-vector";
      bgMode="map";
      setCanvasBg("transparent");
    }
  };
  document.getElementById("bgColor").oninput = function(){
    if(bgMode==="blank") setCanvasBg(this.value);
  };

  // slideshow: shuffle + zoom random sugli extent visibili
  document.getElementById("btnShow").onclick = async function(){
    if(showTimer){ clearInterval(showTimer); showTimer=null; this.textContent="üéûÔ∏è"; return; }
    this.textContent="‚èπ";
    showTimer = setInterval(async ()=>{
      doGlobalShuffle();
      const ext = await unionVisibleExtent();
      if(ext){
        const x = ext.xmin + Math.random()*(ext.xmax - ext.xmin);
        const y = ext.ymin + Math.random()*(ext.ymax - ext.ymin);
        const scale = 20000 + Math.random()*(200000 - 20000);
        view.goTo({ center:{x,y,spatialReference:ext.spatialReference}, scale }).catch(()=>{});
      }
    }, 8000);
  };

  // shuffle globale
  document.getElementById("btnShuffleGlobal").onclick = doGlobalShuffle;
  function doGlobalShuffle(){
    SHUFFLE_TICK++;
    PALETTE_PERM.clear();
    LAYERS.filter(e=>e.layer.visible).forEach(e=> shuffleColors(e, true, SHUFFLE_TICK));
    refreshLayerCards();
  }

  /* ===== server list ===== */
  initServerList();
  document.getElementById("btnLoadSelected").onclick = async function(){
    const checks = Array.from(document.querySelectorAll('#serverWrap input[type="checkbox"]')).filter(x=>x.checked).map(x=>x.value);
    if(!checks.length){ for(const it of SERVER_ITEMS){ await ensure(it.path); } return; }
    for(const p of checks){ await ensure(p); }
  };
  document.getElementById("btnLoadAll").onclick = async function(){
    for(const it of SERVER_ITEMS){ await ensure(it.path); }
  };

  /* ===== file locali ===== */
  document.getElementById("fileInput").addEventListener("change", async function(ev){
    const files = ev.target.files;
    for(let i=0;i<files.length;i++){
      const f = files[i];
      try{
        const obj = JSON.parse(await f.text());
        if(isPaletteObject(obj)){ mergePalettes(obj); buildPaletteGallery(); continue; }
        const base = f.name.replace(/\.[^.]+$/,"");
        if(obj.type==="Topology"){
          const names = Object.keys(obj.objects||{}); if(!names.length) continue;
          let pick = names[0], maxn=0;
          for(const n of names){ const g=obj.objects[n]; const cnt=(g && g.geometries||[]).length; if(cnt>maxn){maxn=cnt; pick=n;} }
          const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
          await addFromGeoJSONObject(geo, base);
        }else{
          await addFromGeoJSONObject(obj, base);
        }
      }catch(e){ console.error("File err:", f.name, e.message); }
    }
    ev.target.value = "";
  });

  /* ===== helpers ===== */
  async function ensure(path){
    const entry = NAME_TO_ENTRY.get(path);
    if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
    else { await addFromPath(path); NAME_TO_ENTRY.set(path, LAYERS[LAYERS.length-1]); }
  }
  function initServerList(){
    const wrap = document.getElementById("serverWrap"); wrap.innerHTML="";
    SERVER_ITEMS.forEach(item=>{
      const d = document.createElement("div"); d.className="srv";
      const cb = document.createElement("input"); cb.type="checkbox"; cb.value=item.path; cb.title="visibile";
      const lab = document.createElement("label"); lab.textContent = item.label;
      d.appendChild(cb); d.appendChild(lab); wrap.appendChild(d);
      cb.onchange = async function(){
        try{
          const entry = NAME_TO_ENTRY.get(item.path);
          if(cb.checked){
            if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
            else { await addFromPath(item.path); NAME_TO_ENTRY.set(item.path, LAYERS[LAYERS.length-1]); }
          }else{
            if(entry){ entry.visible=false; entry.layer.visible=false; refreshLayerCards(); }
          }
        }catch(e){
          console.warn("Non trovato:", item.path);
          cb.checked = false;
        }
      };
    });
  }

  async function addFromPath(path){
    try{
      const resp = await fetch(path,{cache:"no-store"});
      if(!resp.ok) throw new Error("HTTP "+resp.status);
      const obj = JSON.parse(await resp.text());
      if(obj.type==="Topology"){
        const names = Object.keys(obj.objects||{}); if(!names.length) throw new Error("TopoJSON senza objects");
        let pick = names[0], maxn=0;
        for(const n of names){ const g=obj.objects[n]; const cnt=(g && g.geometries||[]).length; if(cnt>maxn){maxn=cnt; pick=n;} }
        const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
        await addFromGeoJSONObject(geo, path.replace(/^.*[\\/]/,"").replace(/\.[^.]+$/,""));
      }else{
        await addFromGeoJSONObject(obj, path.replace(/^.*[\\/]/,"").replace(/\.[^.]+$/,""));
      }
    }catch(e){
      console.warn("Errore su", path, e.message);
      throw e;
    }
  }

  async function addFromGeoJSONObject(obj, titleBase){
    const blob = new Blob([JSON.stringify(obj)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const layer = new GeoJSONLayer({ url, title:titleBase });
    map.add(layer);
    const entry = { layer, title:titleBase, groupField:null, paletteName:null, opacity:1, override:null, visible:true, fields:[] };
    LAYERS.push(entry);

    layer.when(async function(){
      entry.fields = await sampleFields(layer);
      entry.groupField = pickBestField(entry.fields);          // legenda di default
      entry.paletteName = PALETTE_NAMES[0] || null;            // palette di default
      applyPalette(entry);                                     // renderer applicato
      refreshLayerCards();
      try{ const ex=await layer.queryExtent(); if(ex.extent) view.goTo(ex.extent.expand(1.05)); }catch(e){}
    });
  }
  async function sampleFields(layer){
    try{
      const q = layer.createQuery(); q.outFields=["*"]; q.returnGeometry=false; q.num=1;
      const r = await layer.queryFeatures(q);
      if(r.features.length){ return Object.keys(r.features[0].attributes||{}); }
    }catch(e){}
    return [];
  }
  function pickBestField(fields){
    const pref=["group20","group_nac","Rank20","group","rank"];
    for(const p of pref){ if(fields.includes(p)) return p; }
    for(const k of fields){ if(!/^(OBJECTID|FID|id)$/i.test(k)) return k; }
    return fields[0]||null;
  }

  function buildRenderer(field, palette, override){
    const infos = [];
    for(let i=1;i<=20;i++){
      const inv = 21 - i;
      const hex = (override && override[String(inv)]) || (palette && palette.colors[String(inv)]) || "#cccccc";
      infos.push({ value:i, symbol:{ type:"simple-fill", color:hex, outline:{color:[0,0,0,0], width:0} }, label:"Classe "+i });
    }
    return { type:"unique-value", field, uniqueValueInfos:infos,
      defaultSymbol:{ type:"simple-fill", color:[220,220,220,0], outline:{color:[0,0,0,0], width:0} } };
  }
  function applyPalette(entry){
    if(!entry.groupField || !entry.paletteName) return;
    const pal = PALETTES[entry.paletteName];
    entry.layer.renderer = buildRenderer(entry.groupField, pal, entry.override);
    entry.layer.opacity = entry.opacity || 1;
  }

  function seededShuffle(arr, seedStr){
    let seed=0; for(let i=0;i<seedStr.length;i++) seed=(seed*31 + seedStr.charCodeAt(i))>>>0;
    function rnd(){ seed=(1103515245*seed+12345)%0x80000000; return seed/0x80000000; }
    const a=arr.slice(); for(let k=a.length-1;k>0;k--){ const j=Math.floor(rnd()*(k+1)); [a[k],a[j]]=[a[j],a[k]]; } return a;
  }
  function linkShuffleForPalette(paletteName, tick){
    const key = paletteName + "#" + tick;
    if(PALETTE_PERM.has(key)) return PALETTE_PERM.get(key);
    const ranks = Array.from({length:20},(_,i)=>String(i+1));
    const perm = seededShuffle(ranks, key);
    PALETTE_PERM.set(key, perm);
    return perm;
  }
  function shuffleColors(entry, link=true, tick=0){
    if(!entry.paletteName) return;
    const pal = PALETTES[entry.paletteName];
    const ranks = Array.from({length:20},(_,i)=>String(i+1));
    const src = ranks.map(r=>pal.colors[r]);
    const ord = link ? linkShuffleForPalette(entry.paletteName, tick)
                     : seededShuffle(ranks, entry.title + Date.now());
    entry.override = {};
    ord.forEach((rank,i)=> entry.override[rank]=src[i]);
    applyPalette(entry); updateCard(entry);
  }

  function updateCard(entry){
    const idx = LAYERS.indexOf(entry);
    const host = document.getElementById("sw-"+idx);
    if(!host) return;
    host.innerHTML = "";
    if(!entry.paletteName) return;
    const pal = entry.override ? {colors:entry.override} : PALETTES[entry.paletteName];
    const frag = document.createDocumentFragment();
    for(let i=1;i<=20;i++){
      const s=document.createElement("span"); s.className="swatch"; s.style.background=pal.colors[String(i)];
      frag.appendChild(s);
    }
    host.appendChild(frag);
  }

  /* layer cards */
  const layersWrap = document.getElementById("layersWrap");
  function refreshLayerCards(){
    layersWrap.innerHTML = "";
    LAYERS.forEach((entry, idx)=>{
      const card = document.createElement("div"); card.className="card";
      const h = document.createElement("h5"); h.textContent = entry.title; card.appendChild(h);

      const r1 = document.createElement("div"); r1.className="row";
      r1.innerHTML =
        "<label class='muted'>Sel</label><input type='checkbox' id='sel-"+idx+"'>" +
        "<label class='muted' style='margin-left:8px'>Vis</label><input type='checkbox' id='vis-"+idx+"' "+(entry.visible?"checked":"")+">" +
        "<label class='muted' style='margin-left:8px'>Opacit√†</label><input type='range' id='op-"+idx+"' min='0' max='1' step='0.05' value='"+(entry.opacity||1)+"' class='grow'>";
      card.appendChild(r1);

      const r2 = document.createElement("div"); r2.className="row";
      const selField = document.createElement("select"); selField.id="gf-"+idx; selField.className="grow";
      orderFields(entry.fields).forEach(f=>{ const o=document.createElement("option"); o.value=f; o.textContent=f; selField.appendChild(o); });
      if(entry.groupField) selField.value = entry.groupField;

      const selPal = document.createElement("select"); selPal.id="pal-"+idx; selPal.style.minWidth="140px";
      PALETTE_NAMES.forEach(n=>{ const o=document.createElement("option"); o.value=n; o.textContent=n; selPal.appendChild(o); });
      if(entry.paletteName) selPal.value = entry.paletteName;

      r2.appendChild(labelSmall("Campo")); r2.appendChild(selField);
      r2.appendChild(labelSmall("Palette")); r2.appendChild(selPal);
      card.appendChild(r2);

      const r3 = document.createElement("div"); r3.className="row";
      const b1 = chip("üé≤ Shuffle"), b2=chip("Reset"), b3=chip("Rimuovi");
      r3.appendChild(b1); r3.appendChild(b2); r3.appendChild(b3);
      card.appendChild(r3);

      const sw = document.createElement("div"); sw.id="sw-"+idx; sw.className="row"; sw.style.marginTop="6px";
      card.appendChild(sw);

      layersWrap.appendChild(card);

      document.getElementById("vis-"+idx).onchange = function(){ entry.visible=this.checked; entry.layer.visible=this.checked; };
      document.getElementById("op-"+idx).oninput = function(){ entry.opacity=Number(this.value); entry.layer.opacity=entry.opacity; };
      selField.onchange = function(){ entry.groupField=this.value; applyPalette(entry); updateCard(entry); };
      selPal.onchange   = function(){ entry.paletteName=this.value; entry.override=null; applyPalette(entry); updateCard(entry); };
      b1.onclick = function(){ shuffleColors(entry, true, ++SHUFFLE_TICK); };
      b2.onclick = function(){ entry.override=null; applyPalette(entry); updateCard(entry); };
      b3.onclick = function(){ map.remove(entry.layer); const k=LAYERS.indexOf(entry); if(k>=0) LAYERS.splice(k,1); refreshLayerCards(); };

      updateCard(entry);
    });
  }
  function labelSmall(t){ const l=document.createElement("label"); l.className="muted"; l.textContent=t; return l; }
  function chip(t){ const b=document.createElement("button"); b.className="chip"; b.textContent=t; return b; }
  function orderFields(arr){
    const pref=["group20","group_nac","Rank20","group","rank"], set=new Set(arr||[]), out=[];
    pref.forEach(p=>{ if(set.has(p)) out.push(p); }); arr.forEach(k=>{ if(!out.includes(k)) out.push(k); }); return out;
  }

  /* palette gallery */
  function buildPaletteGallery(){
    const host=document.getElementById("palGallery"); host.innerHTML="";
    PALETTE_NAMES.forEach(name=>{
      const p=PALETTES[name];
      const card=document.createElement("div"); card.className="pal"; card.title="Applica "+name;
      const top=document.createElement("div"); top.className="pal-top";
      const left=document.createElement("div"); left.textContent=name;
      const links=document.createElement("div"); links.className="pal-links";
      if(p.links){
        if(p.links.google_images){ const a=document.createElement("a"); a.href=p.links.google_images; a.target="_blank"; a.title="Google Images"; a.textContent="üîç"; links.appendChild(a); }
        if(p.links.wikipedia){ const a2=document.createElement("a"); a2.href=p.links.wikipedia; a2.target="_blank"; a2.title="Wikipedia"; a2.textContent="üìñ"; links.appendChild(a2); }
        if(p.links.google_arts_culture){ const a3=document.createElement("a"); a3.href=p.links.google_arts_culture; a3.target="_blank"; a3.title="Google Arts & Culture"; a3.textContent="üèõÔ∏è"; links.appendChild(a3); }
        if(p.links.wikiart){ const a4=document.createElement("a"); a4.href=p.links.wikiart; a4.target="_blank"; a4.title="WikiArt"; a4.textContent="üé®"; links.appendChild(a4); }
      }
      top.appendChild(left); top.appendChild(links);

      const r1=document.createElement("div"); r1.className="sw10";
      const r2=document.createElement("div"); r2.className="sw10";
      for(let i=1;i<=10;i++){ const s=document.createElement("div"); s.className="sw"; s.style.background=p.colors[String(i)]; r1.appendChild(s); }
      for(let j=11;j<=20;j++){ const s=document.createElement("div"); s.className="sw"; s.style.background=p.colors[String(j)]; r2.appendChild(s); }

      card.appendChild(top); card.appendChild(r1); card.appendChild(r2);

      card.onclick = function(){
        const targets = LAYERS.filter((e,idx)=>{ const c=document.getElementById("sel-"+idx); return c && c.checked; });
        const dest = targets.length ? targets : LAYERS.filter(e=>e.visible);
        dest.forEach(e=>{ e.paletteName=name; e.override=null; applyPalette(e); updateCard(e); });
        refreshLayerCards();
      };
      host.appendChild(card);
    });
  }

  /* init palette di default */
  (async function(){
    try{
      const r = await fetch(DEFAULT_PALETTE_URL,{cache:"no-store"});
      if(r.ok){ mergePalettes(await r.json()); buildPaletteGallery(); }
      else { console.warn("palette_from_tbw.json non trovato:", r.status); }
    }catch(e){ console.warn("Palette default non caricate:", e.message); }
  })();

  function isPaletteObject(obj){
    if(!obj) return false;
    if(Array.isArray(obj.palettes)) return true;
    const v = Object.values(obj)[0];
    return v && v.colors;
  }
  function mergePalettes(raw){
    const out={...PALETTES};
    function add(name, colors, links){
      const norm={}; for(let i=1;i<=20;i++){ const k=String(i); norm[k]=colors[k]||colors[i]; }
      if(Object.values(norm).some(v=>!v)) return;
      out[name]={name,colors:norm,links:links||null};
    }
    if(Array.isArray(raw && raw.palettes)){
      raw.palettes.forEach(p=> add(p.name||"Senza nome", p.colors||{}, p.links||null));
    }else if(raw && typeof raw==="object"){
      Object.keys(raw).forEach(name=>{
        const p=raw[name];
        add(name,(p&&p.colors)||{},p&&p.links);
      });
    }
    PALETTES=out; PALETTE_NAMES=Object.keys(out).sort();
  }

  async function unionVisibleExtent(){
    const vis = LAYERS.filter(e=>e.layer.visible);
    if(!vis.length) return null;
    let u=null;
    for(const e of vis){
      try{ const ex=await e.layer.queryExtent(); if(ex && ex.extent){ u = u ? u.union(ex.extent) : ex.extent; } }
      catch(_){}
    }
    return u || view.extent;
  }

}); // require end
</script>
</body>
</html>
