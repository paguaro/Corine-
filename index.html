<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Corine ‚Äì distretti & palette</title>

<link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css">
<script src="https://js.arcgis.com/4.33/"></script>

<!-- TopoJSON come ES Module (evita multipleDefine) -->
<script type="module">
  import * as topojson from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";
  window.topojsonClient = topojson;
</script>

<style>
  html,body,#viewDiv{height:100%;margin:0}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  /* pannello layer (raccoglibile) */
  #panel{position:absolute;top:10px;left:10px;z-index:20;background:#fff;padding:12px;border-radius:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.2);font-size:14px;max-width:560px;max-height:92%;overflow:auto}
  #panel.collapsed{display:none}
  #panelToggle{position:absolute;top:10px;left:10px;z-index:21;border:none;border-radius:10px;background:#fff;
    box-shadow:0 6px 18px rgba(0,0,0,.2);width:40px;height:40px;cursor:pointer;font-size:18px}

  .row{display:flex;gap:8px;align-items:center;margin:.5rem 0}
  .grow{flex:1}
  .muted{color:#666}
  button,select,input{font:inherit}
  input[type="range"]{width:100%}
  #log{font-size:12px;max-height:150px;overflow:auto;margin-top:6px}

  .card{border:1px solid #e5e7eb;border-radius:10px;background:#fafafa;padding:10px;margin-top:10px}
  .card h4{margin:.2rem 0 .6rem 0;font-size:14px}

  /* lista file server ‚Äì compatta */
  #serverWrap{
    display:grid;
    grid-template-columns:repeat(auto-fill,minmax(150px,1fr));
    gap:6px
  }
  .srv-item{
    display:grid;
    grid-template-columns:auto 1fr;
    align-items:center;
    gap:6px;
    border:1px solid #e5e7eb;
    border-radius:8px;
    background:#fff;
    padding:6px 8px
  }
  .srv-name{font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  /* palette gallery (raccoglibile) */
  #palToggle{position:absolute;left:60px;top:10px;z-index:21;border:none;border-radius:10px;background:#fff;
    box-shadow:0 6px 18px rgba(0,0,0,.2);height:40px;padding:0 10px;cursor:pointer}
  #palPanel{position:absolute;left:60px;top:60px;z-index:20;display:none;background:#fff;border-radius:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.25);padding:12px;max-height:65%;overflow:auto;min-width:420px}
  .pal-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .pal-item{border:1px solid #eee;border-radius:10px;padding:8px;margin-bottom:8px;cursor:pointer}
  .pal-title{font-weight:600;margin-bottom:6px}
  .sw-row{display:grid;grid-template-columns:repeat(10,1fr);gap:4px}
  .sw{height:14px;border-radius:3px;border:1px solid #ddd}

  /* basemap & export */
  #bm-toggle{position:absolute;right:70px;bottom:15px;z-index:25;width:42px;height:42px;border-radius:999px;border:none;
    background:#ffffff;box-shadow:0 6px 18px rgba(0,0,0,.3);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px}
  #bm-panel{position:absolute;right:70px;bottom:70px;z-index:24;display:none;background:#fff;border-radius:12px;
    box-shadow:0 6px 18px rgba(0,0,0,.25);padding:10px;min-width:220px}
  #bm-panel label{display:block;font-size:12px;color:#555;margin-bottom:4px}

  #btnExport{position:absolute;right:125px;bottom:15px;z-index:26;border:none;border-radius:999px;padding:10px 14px;
    background:#fff;box-shadow:0 6px 18px rgba(0,0,0,.3);cursor:pointer}

  /* shuffle globale */
  #btnShuffleGlobal{position:absolute;left:15px;bottom:15px;z-index:26;border:none;border-radius:999px;padding:10px 14px;
    background:#fff;box-shadow:0 6px 18px rgba(0,0,0,.3);cursor:pointer}

  /* toast click info */
  #toast{position:absolute;bottom:65px;left:15px;z-index:30;background:#111;color:#fff;border-radius:10px;padding:10px 12px;
    box-shadow:0 6px 18px rgba(0,0,0,.4);display:none;max-width:80%}
  #toast button{margin-left:8px;border:none;border-radius:8px;padding:4px 8px;cursor:pointer}
</style>
</head>
<body>
<div id="viewDiv"></div>

<!-- toggles -->
<button id="panelToggle" title="Mostra/Nascondi pannello">‚ò∞</button>
<button id="palToggle" title="Palette">üé® Palette</button>

<!-- basemap & export -->
<button id="bm-toggle" title="Basemap">üó∫Ô∏è</button>
<div id="bm-panel">
  <label>Mappa di base</label>
  <select id="bm-select">
    <option value="gray-vector">Grigio (vector)</option>
    <option value="topo-vector">Topografica (vector)</option>
    <option value="streets-vector">Strade (vector)</option>
    <option value="satellite">Satellite</option>
    <option value="hybrid">Ibrida</option>
    <option value="oceans">Oceani</option>
    <option value="dark-gray-vector">Grigio scuro (vector)</option>
    <option value="terrain">Terreno</option>
    <option value="osm-standard">OSM Standard</option>
  </select>
</div>
<button id="btnExport" title="Esporta PNG mappa">Export PNG</button>

<!-- shuffle globale -->
<button id="btnShuffleGlobal" title="Rimescola colori di tutti i layer visibili">üé≤ Shuffle</button>

<!-- pannello layer -->
<div id="panel">
  <div class="row"><strong>Controlli globali</strong></div>
  <div class="row">
    <label class="muted">Campo legenda</label>
    <label><input type="radio" name="globalFieldUi" value="distrital" checked> Distrital</label>
    <label><input type="radio" name="globalFieldUi" value="nacional"> Nacional</label>
    <button id="btnApplyGlobalField">Applica ai layer visibili</button>
  </div>
  <div class="row" style="align-items:flex-start">
    <button id="btnApplyActivePalette">Applica palette attiva ai layer visibili</button>
    <div id="activePalTag" class="muted grow"></div>
  </div>

  <hr>
  <div class="row"><strong>Layer sul server</strong></div>
  <div id="serverWrap"></div>
  <div class="row">
    <button id="btnLoadSelected">Carica selezionati</button>
    <button id="btnLoadAll">Carica tutti</button>
    <span class="muted grow" style="text-align:right">oppure</span>
  </div>
  <div class="row">
    <input id="fileInput" class="grow" type="file" accept=".topojson,.geojson" multiple>
    <span class="muted">file locali</span>
  </div>

  <hr>
  <div><strong>Layer caricati</strong></div>
  <div id="layersWrap"></div>

  <hr>
  <div><strong>Log</strong></div>
  <div id="log"></div>
</div>

<!-- palette gallery -->
<div id="palPanel"></div>

<!-- toast -->
<div id="toast"><span id="toastText"></span><button id="btnCopy">Copia</button></div>

<script>
/* ===== Nomi base (senza .topojson) ===== */
const SERVER_LAYERS = [
  "AVEIRO","BEJA","BRAGA","BRAGANCA","CASTELO_BRANCO","COIMBRA","EVORA","FARO",
  "GUARDA","LEIRIA","LISBOA","PORTALEGRE","PORTO","SANTAREM","SETUBAL",
  "VIANA_DO_CASTELO","VILA_REAL","VISEU"
];

/* ===== Stato app ===== */
let PALETTES = {};               // {name:{name, colors{1..20:"#hex"}}}
let ACTIVE_PALETTE_NAMES = [];
let activePaletteName = null;    // palette ‚Äúattiva‚Äù (gallery)
const LAYERS = [];               // [{layer,title,groupField,opacity,override,basePalette,visible}]
let map, view;

/* ===== Init mappa ===== */
require(["esri/Map","esri/views/MapView","esri/layers/GeoJSONLayer"], (EsriMap,MapView,GeoJSONLayer)=>{

  map = new EsriMap({ basemap:"gray-vector" });
  view = new MapView({ container:"viewDiv", map, center:[-8,39.5], zoom:7 });
  view.ui.move("zoom","top-right");

  // pannelli
  const panel = document.getElementById("panel");
  document.getElementById("panelToggle").onclick = ()=> panel.classList.toggle("collapsed");

  const palPanel = document.getElementById("palPanel");
  document.getElementById("palToggle").onclick = ()=> palPanel.style.display = (palPanel.style.display==="block"?"none":"block");

  // basemap
  const btnBM = document.getElementById("bm-toggle");
  const pnlBM = document.getElementById("bm-panel");
  const selBM = document.getElementById("bm-select");
  btnBM.onclick = ()=> pnlBM.style.display = (pnlBM.style.display==="none" || !pnlBM.style.display) ? "block" : "none";
  selBM.onchange = ()=>{ map.basemap = selBM.value; };

  // export PNG
  document.getElementById("btnExport").onclick = async ()=>{
    try{
      const shot = await view.takeScreenshot({ format:"png", quality: 100 });
      const a = document.createElement("a");
      a.href = shot.dataUrl;
      a.download = `map_${new Date().toISOString().replace(/[:.]/g,"-")}.png`;
      a.click();
    }catch(e){ log("Errore export PNG: "+e.message,"err"); }
  };

  // toast
  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  document.getElementById("btnCopy").onclick = async ()=>{
    try{ await navigator.clipboard.writeText(toastText.textContent||""); toast.style.display="none"; log("Copiato negli appunti","ok"); }
    catch(e){ log("Copy fallita","err"); }
  };
  view.on("click", async (event)=>{
    try{
      const hit = await view.hitTest(event);
      const g = hit.results?.find(r=>r.graphic?.layer?.type==="geojson");
      if(!g){ toast.style.display="none"; return; }
      const entry = LAYERS.find(x=>x.layer===g.graphic.layer);
      if(!entry){ toast.style.display="none"; return; }
      const attrs = g.graphic.attributes || {};
      const field = entry.groupField;
      const val = attrs[field];
      const rend = entry.layer.renderer;
      let hex = "#000000";
      if(rend?.uniqueValueInfos){
        const it = rend.uniqueValueInfos.find(u=>String(u.value)==String(val));
        if(it?.symbol?.color) hex = Array.isArray(it.symbol.color) ? rgbaToHex(it.symbol.color) : it.symbol.color;
      }
      toastText.textContent = `layer: ${entry.title} | ${field}=${val} | color=${hex}`;
      toast.style.display = "inline-flex";
    }catch{}
  });
  function rgbaToHex(c){ const r=c[0]??0,g=c[1]??0,b=c[2]??0; return "#"+[r,g,b].map(x=>x.toString(16).padStart(2,"0")).join(""); }

  // LOG
  const log = (msg,cls="")=>{
    const div=document.getElementById("log");
    const el=document.createElement("div"); if(cls) el.className=cls;
    el.textContent=msg; div.appendChild(el); div.scrollTop=div.scrollHeight;
    console[cls==="err"?"error":cls==="ok"?"log":"log"](msg);
  };

  /* ===== Palettes ===== */
  async function loadPalettes(){
    try{
      const r = await fetch("./palettes_from_twb.json",{cache:"no-store"});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      const raw = await r.json();
      const out = {};
      const add = (name, colors)=>{
        const norm={}; for(let i=1;i<=20;i++) norm[String(i)] = colors[String(i)] ?? colors[i];
        if(Object.values(norm).some(v=>!v)) return;
        out[name] = { name, colors:norm };
      };
      if(Array.isArray(raw?.palettes)){
        raw.palettes.forEach(p=> add(p.name||"Senza nome", p.colors||{}));
      }else{
        Object.entries(raw||{}).forEach(([name,p])=> add(name, p?.colors||{}));
      }
      PALETTES = out; ACTIVE_PALETTE_NAMES = Object.keys(out).sort();
      activePaletteName = ACTIVE_PALETTE_NAMES[0] || null;
      buildPaletteGallery();
      updateActivePalTag();
      log(`Palette caricate: ${ACTIVE_PALETTE_NAMES.length}`,"ok");
    }catch(e){
      log("Impossibile caricare palettes_from_twb.json (nessuna palette disponibile)","err");
    }
  }

  function buildPaletteGallery(){
    const panel = document.getElementById("palPanel");
    panel.innerHTML = "";
    const head = document.createElement("div");
    head.className="pal-head";
    head.innerHTML = `<h4 style="margin:0">Palette disponibili</h4>
      <button id="btnApplyActiveFromGallery">Applica palette attiva ai layer visibili</button>`;
    panel.appendChild(head);
    document.getElementById("btnApplyActiveFromGallery").onclick = applyActivePaletteToVisible;

    ACTIVE_PALETTE_NAMES.forEach(name=>{
      const p = PALETTES[name];
      const div=document.createElement("div"); div.className="pal-item"; div.title=`Imposta e applica "${name}"`;
      const title=document.createElement("div"); title.className="pal-title"; title.textContent=name;
      const sw1=document.createElement("div"); sw1.className="sw-row";
      const sw2=document.createElement("div"); sw2.className="sw-row";
      for(let i=1;i<=10;i++){ const c=document.createElement("div"); c.className="sw"; c.style.background=p.colors[String(i)]; sw1.appendChild(c); }
      for(let i=11;i<=20;i++){ const c=document.createElement("div"); c.className="sw"; c.style.background=p.colors[String(i)]; sw2.appendChild(c); }
      div.appendChild(title); div.appendChild(sw1); div.appendChild(sw2);
      div.onclick = ()=>{
        activePaletteName = name;
        updateActivePalTag();
        applyActivePaletteToVisible(); // applica SUBITO a tutti i layer visibili
      };
      panel.appendChild(div);
    });
  }

  function renderSwatches(colors){
    const wrap=document.createElement("div");
    wrap.className="sw-row";
    for(let i=1;i<=10;i++){
      const s=document.createElement("div"); s.className="sw"; s.style.background=colors[String(i)];
      wrap.appendChild(s);
    }
    const wrap2=document.createElement("div"); wrap2.className="sw-row";
    for(let i=11;i<=20;i++){
      const s=document.createElement("div"); s.className="sw"; s.style.background=colors[String(i)];
      wrap2.appendChild(s);
    }
    const container=document.createElement("div");
    container.appendChild(wrap); container.appendChild(wrap2);
    return container.outerHTML;
  }

  function updateActivePalTag(){
    const el = document.getElementById("activePalTag");
    if(!activePaletteName){ el.textContent="(nessuna palette attiva)"; return; }
    const p = PALETTES[activePaletteName];
    el.innerHTML = `Palette attiva: <strong>${activePaletteName}</strong><br>${renderSwatches(p.colors)}`;
  }

  /* ===== Renderer ===== */
  function buildRenderer(field, palette, override){
    const infos=[];
    for(let i=1;i<=20;i++){
      const rank=String(i);
      const hex=(override && (override[rank])) || palette.colors[rank];
      infos.push({
        value: Number(rank),
        symbol: { type:"simple-fill", color: hex, outline:{ color:[0,0,0,0], width:0 } },
        label:`Classe ${rank}`
      });
    }
    return {
      type:"unique-value",
      field,
      defaultSymbol: { type:"simple-fill", color:[220,220,220,0], outline:{ color:[0,0,0,0], width:0 } },
      uniqueValueInfos: infos
    };
  }

  function applyPalette(entry){
    if(!entry.groupField){ log(`${entry.title}: imposta il campo legenda (Distrital/Nacional)`,`err`); return; }
    if(!entry.basePalette){
      if(!activePaletteName){ log("Nessuna palette attiva: scegli dalla gallery","err"); return; }
      entry.basePalette = PALETTES[activePaletteName];
    }
    entry.layer.renderer = buildRenderer(entry.groupField, entry.basePalette, entry.override);
    entry.layer.opacity = entry.opacity ?? 1;
  }

  function shuffleColors(entry){
    if(!entry.basePalette){ log(`Imposta una palette per ${entry.title}`,"err"); return; }
    const ranks=[...Array(20)].map((_,i)=>String(i+1));
    const cols=ranks.map(r=>entry.basePalette.colors[r]);
    for(let i=cols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [cols[i],cols[j]]=[cols[j],cols[i]]; }
    entry.override = {}; ranks.forEach((r,i)=> entry.override[r]=cols[i]);
    applyPalette(entry);
    updateCardSwatches(entry);
  }

  function resetLayer(entry){
    // torna alla palette attiva (senza shuffle) mantenendo il campo legenda del layer
    if(activePaletteName){ entry.basePalette = PALETTES[activePaletteName]; }
    entry.override = null;
    applyPalette(entry);
    updateCardSwatches(entry);
  }

  function applyActivePaletteToVisible(){
    if(!activePaletteName){ log("Seleziona prima una palette nella gallery","err"); return; }
    const p = PALETTES[activePaletteName];
    LAYERS.filter(e=>e.visible).forEach(e=>{
      e.basePalette = p;
      e.override = null;
      applyPalette(e);
      updateCardSwatches(e);
    });
    refreshLayerCards();
  }

  /* ===== Caricamento dati ===== */
  async function addFromGeoJSONObject(obj, titleBase){
    const blob=new Blob([JSON.stringify(obj)],{type:"application/json"});
    const blobUrl=URL.createObjectURL(blob);
    const layer=new GeoJSONLayer({ url: blobUrl, title: titleBase });
    map.add(layer);
    const entry={ layer, title:titleBase, groupField:null, opacity:1, override:null, basePalette:null, visible:true };
    LAYERS.push(entry);
    layer.when(async()=>{
      entry.groupField = await detectGroupField(layer);
      if(activePaletteName) entry.basePalette = PALETTES[activePaletteName];
      applyPalette(entry);
      refreshLayerCards();
      try{ const ex=await layer.queryExtent(); if(ex.extent) view.goTo(ex.extent.expand(1.05)); }catch{}
      log(`Caricato: ${titleBase}`,"ok");
    });
  }

  async function addFromURL(baseName){
    const url = `./${baseName}.topojson`;
    try{
      const resp=await fetch(url,{cache:"no-store"});
      if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const txt=await resp.text();
      let obj=JSON.parse(txt);
      if(obj.type==="Topology"){
        const names=Object.keys(obj.objects||{}); if(!names.length) throw new Error("TopoJSON senza objects");
        let pick = names[0], maxn=0;
        for(const n of names){ const g=obj.objects[n]; const cnt=(g?.geometries||[]).length; if(cnt>maxn){maxn=cnt; pick=n;} }
        const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
        await addFromGeoJSONObject(geo, baseName);
      }else{
        const isGeo = obj && ((obj.type==="FeatureCollection"&&Array.isArray(obj.features))||(obj.type==="Feature"&&obj.geometry));
        if(!isGeo) throw new Error("Formato non riconosciuto");
        await addFromGeoJSONObject(obj, baseName);
      }
    }catch(e){ log(`Errore "${baseName}": ${e.message}`,"err"); }
  }

  async function detectGroupField(layer){
    const prefs=["group20","group_nac","RANK","group","Rank20"];
    try{
      const q=layer.createQuery(); q.outFields=["*"]; q.returnGeometry=false; q.num=1;
      const r=await layer.queryFeatures(q);
      if(r.features.length){
        const attrs=r.features[0].attributes;
        for(const k of prefs){ if(k in attrs) return k; }
        const keys=Object.keys(attrs);
        return keys.find(k=>k!=="OBJECTID"&&k!=="FID")||keys[0]||null;
      }
    }catch{}
    return null;
  }

  /* ===== UI ‚Äî Server (compatta) ===== */
  const serverWrap = document.getElementById("serverWrap");
  function initServerList(){
    serverWrap.innerHTML="";
    SERVER_LAYERS.forEach(name=>{
      const it=document.createElement("div"); it.className="srv-item";
      const cb=document.createElement("input"); cb.type="checkbox"; cb.value=name;
      const lbl=document.createElement("div"); lbl.className="srv-name"; lbl.textContent=name.replace(/_/g," ");
      it.appendChild(cb); it.appendChild(lbl);
      serverWrap.appendChild(it);

      cb.onchange = async ()=>{
        const entry = LAYERS.find(e=>e.title===name);
        if(cb.checked){
          if(entry){ entry.visible = true; entry.layer.visible = true; refreshLayerCards(); }
          else      await addFromURL(name);
        }else{
          if(entry){ entry.visible = false; entry.layer.visible = false; refreshLayerCards(); }
        }
      };
    });

    document.getElementById("btnLoadSelected").onclick = async ()=>{
      const checks=[...serverWrap.querySelectorAll('input[type="checkbox"]')];
      const picked=checks.filter(x=>x.checked).map(x=>x.value);
      if(!picked.length){
        log("Nessun layer selezionato: attivo e carico tutti","ok");
        await loadAllServerLayers(checks);
      }else{
        for(const n of picked){
          const cb = checks.find(x=>x.value===n); if(cb) cb.checked = true;
          const entry = LAYERS.find(e=>e.title===n);
          if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
          else      await addFromURL(n);
        }
      }
    };

    document.getElementById("btnLoadAll").onclick = async ()=>{
      const checks=[...serverWrap.querySelectorAll('input[type="checkbox"]')];
      await loadAllServerLayers(checks);
    };
  }

  async function loadAllServerLayers(checks){
    for(const cb of checks){ cb.checked = true; }
    for(const n of SERVER_LAYERS){
      const entry = LAYERS.find(e=>e.title===n);
      if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
      else      await addFromURL(n);
    }
  }

  /* ===== UI ‚Äî File locali ===== */
  document.getElementById("fileInput").addEventListener("change", async ev=>{
    for(const f of ev.target.files){
      try{
        const txt=await f.text(); const obj=JSON.parse(txt);
        const base = f.name.replace(/\.[^.]+$/,"");
        if(obj.type==="Topology"){
          const names=Object.keys(obj.objects||{}); if(!names.length){ log(`TopoJSON senza objects: ${f.name}`,"err"); continue; }
          let pick = names[0], maxn=0;
          for(const n of names){ const g=obj.objects[n]; const cnt=(g?.geometries||[]).length; if(cnt>maxn){maxn=cnt; pick=n;} }
          const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
          await addFromGeoJSONObject(geo, base);
        }else{
          const isGeo = obj && ((obj.type==="FeatureCollection"&&Array.isArray(obj.features))||(obj.type==="Feature"&&obj.geometry));
          if(!isGeo){ log(`"${f.name}" non √® GeoJSON/TopoJSON valido`,"err"); continue; }
          await addFromGeoJSONObject(obj, base);
        }
      }catch(e){ log(`Errore file ${f.name}: ${e.message}`,"err"); }
    }
    ev.target.value="";
  });

  /* ===== UI ‚Äî Layer cards ===== */
  const layersWrap = document.getElementById("layersWrap");

  // mappatura etichette UI -> nomi campo reali
  function uiToFieldName(val){ return val === "nacional" ? "group_nac" : "group20"; }

  function refreshLayerCards(){
    layersWrap.innerHTML="";
    LAYERS.forEach((entry,idx)=>{
      const card=document.createElement("div"); card.className="card";
      const currentUi = entry.groupField === "group_nac" ? "nacional" : (entry.groupField === "group20" ? "distrital" : "custom");
      card.innerHTML=`
        <h4>${entry.title}</h4>
        <div class="row" style="gap:12px">
          <label class="muted">Visibile</label>
          <input type="checkbox" id="vis-${idx}" ${entry.visible?"checked":""}>
          <span style="width:8px"></span>
          <label class="muted">Campo legenda</label>
          <select id="gfsel-${idx}">
            <option value="distrital" ${currentUi==="distrital"?"selected":""}>Distrital</option>
            <option value="nacional" ${currentUi==="nacional"?"selected":""}>Nacional</option>
            ${currentUi==="custom" ? `<option value="__custom" selected>Custom (${entry.groupField})</option>` : ""}
          </select>
          <input id="gfcustom-${idx}" type="text" placeholder="custom field" value="${currentUi==="custom"?entry.groupField:""}" style="width:140px; ${currentUi==="custom"?"":"display:none"}">
        </div>
        <div class="row" style="gap:12px">
          <label class="muted">Palette (layer)</label>
          <select id="palsel-${idx}" class="grow"></select>
        </div>
        <div class="row">
          <label class="muted" style="width:90px">Trasparenza</label>
          <input id="op-${idx}" type="range" min="0" max="1" step="0.05" value="${entry.opacity??1}">
        </div>
        <div class="row" style="gap:6px">
          <button id="btnShuffle-${idx}">üé≤ Shuffle</button>
          <button id="btnReset-${idx}">Reset</button>
          <button id="btnRemove-${idx}">Rimuovi</button>
        </div>
        <div class="row"><span class="muted" id="paletteSw-${idx}"></span></div>
      `;
      layersWrap.appendChild(card);

      // visibilit√†
      const vis = card.querySelector(`#vis-${idx}`);
      vis.onchange = ()=>{ entry.visible = vis.checked; entry.layer.visible = entry.visible; };

      // campo legenda (select + custom)
      const gfsel = card.querySelector(`#gfsel-${idx}`);
      const gfcustom = card.querySelector(`#gfcustom-${idx}`);
      gfsel.onchange = async ()=>{
        if(gfsel.value==="__custom"){ gfcustom.style.display="inline-block"; gfcustom.focus(); return; }
        gfcustom.style.display="none";
        const field = uiToFieldName(gfsel.value);
        const ok = await fieldExists(entry.layer, field);
        if(ok){ entry.groupField = field; applyPalette(entry); updateCardSwatches(entry); }
        else{ log(`${entry.title}: campo "${field}" non presente (lasciato invariato)`,"err"); }
      };
      gfcustom.onchange = async ()=>{
        const field = gfcustom.value.trim();
        if(!field){ gfcustom.style.display="none"; return; }
        const ok = await fieldExists(entry.layer, field);
        if(ok){ entry.groupField = field; applyPalette(entry); updateCardSwatches(entry); }
        else{ log(`${entry.title}: campo "${field}" non presente (lasciato invariato)`,"err"); }
      };

      // palette per-layer
      const palSel = card.querySelector(`#palsel-${idx}`);
      ACTIVE_PALETTE_NAMES.forEach(name=>{
        const opt=document.createElement("option"); opt.value=name; opt.textContent=name;
        if(entry.basePalette && entry.basePalette.name===name) opt.selected=true;
        palSel.appendChild(opt);
      });
      palSel.onchange = ()=>{
        entry.basePalette = PALETTES[palSel.value];
        entry.override = null;
        applyPalette(entry);
        updateCardSwatches(entry);
      };
      if(!entry.basePalette && activePaletteName){
        palSel.value = activePaletteName;
      }

      // trasparenza
      const op = card.querySelector(`#op-${idx}`);
      op.oninput = ()=>{ entry.opacity = Number(op.value); entry.layer.opacity = entry.opacity; };

      // shuffle / reset / remove
      card.querySelector(`#btnShuffle-${idx}`).onclick = ()=> shuffleColors(entry);
      card.querySelector(`#btnReset-${idx}`).onclick   = ()=> resetLayer(entry);
      card.querySelector(`#btnRemove-${idx}`).onclick  = ()=>{
        map.remove(entry.layer);
        const k = LAYERS.indexOf(entry);
        if(k>=0) LAYERS.splice(k,1);
        refreshLayerCards();
      };

      updateCardSwatches(entry);
    });
  }

  function updateCardSwatches(entry){
    const k = LAYERS.indexOf(entry);
    const el = document.getElementById(`paletteSw-${k}`);
    if(!el) return;
    const base = entry.basePalette || (activePaletteName ? PALETTES[activePaletteName] : null);
    if(!base){ el.textContent="(nessuna palette assegnata)"; return; }
    const pal = entry.override ? {colors:entry.override} : base;
    el.innerHTML = `Palette: <strong>${base.name}</strong><br>${renderSwatches(pal.colors)}`;
  }

  // globale: shuffle
  document.getElementById("btnShuffleGlobal").onclick = ()=>{
    const vis = LAYERS.filter(e=>e.visible);
    if(!vis.length){ log("Nessun layer visibile","err"); return; }
    vis.forEach(e=> shuffleColors(e));
    refreshLayerCards();
  };

  // globale: campo legenda (Distrital/Nacional)
  document.getElementById("btnApplyGlobalField").onclick = async ()=>{
    const ui = document.querySelector('input[name="globalFieldUi"]:checked')?.value || "distrital";
    const field = uiToFieldName(ui);
    const vis = LAYERS.filter(x=>x.visible);
    if(!vis.length){ log("Nessun layer visibile","err"); return; }
    for(const e of vis){
      const ok = await fieldExists(e.layer, field);
      if(ok){ e.groupField = field; applyPalette(e); }
      else  { log(`${e.title}: campo "${field}" non presente (lasciato invariato)`,"err"); }
    }
    refreshLayerCards();
  };

  // globale: applica palette attiva
  document.getElementById("btnApplyActivePalette").onclick = applyActivePaletteToVisible;

  async function fieldExists(layer, fname){
    try{
      const q=layer.createQuery(); q.outFields=["*"]; q.returnGeometry=false; q.num=1;
      const r=await layer.queryFeatures(q);
      if(r.features.length){
        return Object.prototype.hasOwnProperty.call(r.features[0].attributes, fname);
      }
    }catch{}
    return false;
  }

  // server + palettes
  initServerList();
  loadPalettes();

  /* helpers */
  function initServerList(){
    serverWrap.innerHTML="";
    SERVER_LAYERS.forEach(name=>{
      const it=document.createElement("div"); it.className="srv-item";
      const cb=document.createElement("input"); cb.type="checkbox"; cb.value=name;
      const lbl=document.createElement("div"); lbl.className="srv-name"; lbl.textContent=name.replace(/_/g," ");
      it.appendChild(cb); it.appendChild(lbl);
      serverWrap.appendChild(it);

      cb.onchange = async ()=>{
        const entry = LAYERS.find(e=>e.title===name);
        if(cb.checked){
          if(entry){ entry.visible = true; entry.layer.visible = true; refreshLayerCards(); }
          else      await addFromURL(name);
        }else{
          if(entry){ entry.visible = false; entry.layer.visible = false; refreshLayerCards(); }
        }
      };
    });

    document.getElementById("btnLoadSelected").onclick = async ()=>{
      const checks=[...serverWrap.querySelectorAll('input[type="checkbox"]')];
      const picked=checks.filter(x=>x.checked).map(x=>x.value);
      if(!picked.length){
        log("Nessun layer selezionato: attivo e carico tutti","ok");
        await loadAllServerLayers(checks);
      }else{
        for(const n of picked){
          const cb = checks.find(x=>x.value===n); if(cb) cb.checked = true;
          const entry = LAYERS.find(e=>e.title===n);
          if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
          else      await addFromURL(n);
        }
      }
    };

    document.getElementById("btnLoadAll").onclick = async ()=>{
      const checks=[...serverWrap.querySelectorAll('input[type="checkbox"]')];
      await loadAllServerLayers(checks);
    };
  }

  async function loadAllServerLayers(checks){
    for(const cb of checks){ cb.checked = true; }
    for(const n of SERVER_LAYERS){
      const entry = LAYERS.find(e=>e.title===n);
      if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
      else      await addFromURL(n);
    }
  }

}); // require
</script>
</body>
</html>
