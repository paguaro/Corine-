<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Corine — Layer & Palette</title>

<link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css">
<script src="https://js.arcgis.com/4.33/"></script>

<!-- TopoJSON client as ESM -->
<script type="module">
  import * as topojson from "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm";
  window.topojsonClient = topojson;
</script>

<style>
  html,body,#viewDiv{height:100%;margin:0}
  body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#fff}

  /* ==== Layout principale: pannello sinistro snello + sidebar destra (1/6) ==== */
  #viewDiv{position:absolute; inset:0}
  /* pannello layer (sinistra) */
  #panel{position:absolute; top:12px; left:12px; z-index:30; width:420px; max-height:88vh; overflow:auto;
    background:#fff; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.2); padding:10px}
  #panel.collapsed{display:none}
  #panelToggle{position:absolute; top:12px; left:12px; z-index:31; width:40px; height:40px; border:none; border-radius:10px;
    background:#fff; box-shadow:0 6px 18px rgba(0,0,0,.2); cursor:pointer; font-size:18px}

  /* sidebar palette (a destra, ~1/6) */
  #palSidebar{position:absolute; top:12px; right:12px; bottom:70px; z-index:30; width:min(18vw, 360px); min-width:280px;
    background:#fff; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,.22); padding:10px; overflow:auto}
  #palSidebar.collapsed{display:none}
  #palToggle{position:absolute; top:12px; right:12px; z-index:31; height:40px; padding:0 10px; border:none; border-radius:10px;
    background:#fff; box-shadow:0 6px 18px rgba(0,0,0,.2); cursor:pointer}

  /* contenuti e micro-UI */
  h4{margin:.3rem 0 .5rem 0; font-size:14px}
  .muted{color:#666; font-size:12px}
  .row{display:flex; align-items:center; gap:8px; margin:.4rem 0}
  .grow{flex:1}
  button,select,input{font:inherit}

  /* griglia file server compatta */
  #serverWrap{display:grid; grid-template-columns:repeat(auto-fill,minmax(150px,1fr)); gap:6px}
  .srv{display:flex; align-items:center; gap:6px; border:1px solid #e7e7e7; border-radius:9px; padding:6px; background:#fff}
  .srv label{font-size:13px; font-weight:600; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

  /* cards layer compatte */
  .card{border:1px solid #ececec; border-radius:10px; padding:8px; background:#fafafa; margin-top:8px}
  .card h5{margin:0 0 6px 0; font-size:13px}
  .chips{display:flex; gap:6px; align-items:center}
  .chip{padding:4px 8px; border-radius:999px; background:#fff; border:1px solid #e5e5e5; font-size:12px}

  /* palette items eleganti, zero bottoni */
  .pal-item{border:1px solid #eee; border-radius:10px; padding:8px; margin-bottom:8px; cursor:pointer; background:#fff}
  .pal-title{display:flex; align-items:center; justify-content:space-between; gap:8px; font-weight:600; font-size:13px}
  .pal-links a{font-size:14px; text-decoration:none; opacity:.85; margin-left:6px}
  .pal-links a:hover{opacity:1}
  .sw-row{display:grid; grid-template-columns:repeat(10,1fr); gap:3px; margin-top:6px}
  .sw{height:12px; border-radius:3px; border:1px solid #ddd}

  /* export + shuffle in basso a destra */
  .dockBR{position:absolute; right:12px; bottom:12px; z-index:40; display:flex; gap:8px; align-items:center}
  .pill{border:none; border-radius:999px; padding:10px 14px; background:#fff; box-shadow:0 6px 18px rgba(0,0,0,.28); cursor:pointer}

  /* toast info */
  #toast{position:absolute; left:12px; bottom:70px; z-index:35; display:none; background:#111; color:#fff; border-radius:10px;
    padding:8px 10px; box-shadow:0 6px 18px rgba(0,0,0,.35); max-width:76%}
  #toast button{margin-left:8px; border:none; border-radius:8px; padding:4px 8px; cursor:pointer}

  @media (max-width: 980px){
    #panel{width:92vw}
    #palSidebar{width:calc(100vw - 24px); left:12px; min-width:auto}
  }
</style>
</head>
<body>
  <div id="viewDiv"></div>

  <!-- toggles -->
  <button id="panelToggle" title="Mostra/Nascondi pannello">☰</button>
  <button id="palToggle" title="Palette">🎨 Palette</button>

  <!-- pannello layer -->
  <div id="panel">
    <div class="row" style="justify-content:space-between">
      <strong>Layer & file</strong>
      <span class="muted">legend: per-layer • palette: per-layer</span>
    </div>

    <h4>Layer sul server</h4>
    <div id="serverWrap"></div>
    <div class="row">
      <button id="btnLoadSelected" class="chip">Carica selezionati</button>
      <button id="btnLoadAll" class="chip">Carica tutti</button>
      <span class="muted grow" style="text-align:right">oppure file locali…</span>
    </div>

    <div class="row">
      <input id="fileInput" class="grow" type="file" accept=".topojson,.geojson,.json" multiple>
    </div>

    <h4 style="margin-top:10px">Layer caricati</h4>
    <div id="layersWrap"></div>
  </div>

  <!-- sidebar palette (elegante, click = applica) -->
  <div id="palSidebar">
    <div class="row" style="justify-content:space-between">
      <h4 style="margin:0">Palette</h4>
      <span class="muted">clic per applicare</span>
    </div>
    <div id="palGallery"></div>
  </div>

  <!-- export + shuffle (dock in basso a destra) -->
  <div class="dockBR">
    <button id="btnShuffleGlobal" class="pill" title="Rimescola tutti i layer visibili">🎲 Shuffle</button>
    <button id="btnExport" class="pill" title="Esporta PNG">Export PNG</button>
  </div>

  <!-- toast -->
  <div id="toast"><span id="toastText"></span><button id="btnCopy">Copia</button></div>

<script>
/* ==================== CONFIG ==================== */
const SERVER_ITEMS = [
  {label:"AVEIRO", path:"AVEIRO.topojson"},
  {label:"BEJA", path:"BEJA.topojson"},
  {label:"BRAGA", path:"BRAGA.topojson"},
  {label:"BRAGANCA", path:"BRAGANCA.topojson"},
  {label:"CASTELO BRANCO", path:"CASTELO_BRANCO.topojson"},
  {label:"COIMBRA", path:"COIMBRA.topojson"},
  {label:"EVORA", path:"EVORA.topojson"},
  {label:"FARO", path:"FARO.topojson"},
  {label:"GUARDA", path:"GUARDA.topojson"},
  {label:"LEIRIA", path:"LEIRIA.topojson"},
  {label:"LISBOA", path:"LISBOA.topojson"},
  /* richiesta */
  {label:"LISBOA_BLOCOS", path:"lisboa_blocos.json"},
  {label:"PORTALEGRE", path:"PORTALEGRE.topojson"},
  {label:"PORTO", path:"PORTO.topojson"},
  {label:"SANTAREM", path:"SANTAREM.topojson"},
  {label:"SETUBAL", path:"SETUBAL.topojson"},
  {label:"VIANA DO CASTELO", path:"VIANA_DO_CASTELO.topojson"},
  {label:"VILA REAL", path:"VILA_REAL.topojson"},
  {label:"VISEU", path:"VISEU.topojson"}
];

const DEFAULT_PALETTE_URL = "./palette_from_tbw.json";

/* ==================== STATE ==================== */
let map, view;
let PALETTES = {};                  // name -> {name, colors{1..20}, links?}
let PALETTE_NAMES = [];
const LAYERS = [];                  // objects of loaded GeoJSONLayer
const NAME_TO_ENTRY = new Map();    // path -> entry

/* ==================== ARCGIS ==================== */
require(["esri/Map","esri/views/MapView","esri/layers/GeoJSONLayer"], function(EsriMap, MapView, GeoJSONLayer){

  /* --- map --- */
  map = new EsriMap({ basemap:"gray-vector" });
  view = new MapView({ container:"viewDiv", map, center:[-8,39.5], zoom:7 });
  view.ui.move("zoom","top-right");

  /* toggles */
  document.getElementById("panelToggle").onclick = function(){
    document.getElementById("panel").classList.toggle("collapsed");
  };
  document.getElementById("palToggle").onclick = function(){
    document.getElementById("palSidebar").classList.toggle("collapsed");
  };

  /* export */
  document.getElementById("btnExport").onclick = async function(){
    try{
      const shot = await view.takeScreenshot({ format:"png", quality:100 });
      const a = document.createElement("a");
      a.href = shot.dataUrl;
      a.download = "map_"+new Date().toISOString().replace(/[:.]/g,"-")+".png";
      a.click();
    }catch(e){ console.error(e); }
  };

  /* shuffle globale accanto all’export */
  document.getElementById("btnShuffleGlobal").onclick = function(){
    const vis = LAYERS.filter(e => e.layer.visible);
    if(!vis.length) return;
    vis.forEach(shuffleColors);
    refreshLayerCards();
  };

  /* toast clic mappa */
  const toast = document.getElementById("toast");
  const toastText = document.getElementById("toastText");
  document.getElementById("btnCopy").onclick = async function(){
    try{ await navigator.clipboard.writeText(toastText.textContent||""); toast.style.display="none"; }catch(e){}
  };
  view.on("click", async function(ev){
    const hit = await view.hitTest(ev);
    const g = hit.results && hit.results.find(r => r.graphic && r.graphic.layer && r.graphic.layer.type==="geojson");
    if(!g){ toast.style.display="none"; return; }
    const entry = LAYERS.find(x => x.layer===g.graphic.layer);
    if(!entry){ toast.style.display="none"; return; }
    const attrs = g.graphic.attributes||{};
    const field = entry.groupField;
    const val = attrs[field];
    toastText.textContent = entry.title+" • "+field+"="+val;
    toast.style.display="inline-flex";
  });

  /* server list */
  const serverWrap = document.getElementById("serverWrap");
  function initServerList(){
    serverWrap.innerHTML = "";
    SERVER_ITEMS.forEach(item=>{
      const d = document.createElement("div"); d.className="srv";
      const cb = document.createElement("input"); cb.type="checkbox"; cb.value=item.path; cb.title="visibile";
      const lab = document.createElement("label"); lab.textContent = item.label;
      d.appendChild(cb); d.appendChild(lab); serverWrap.appendChild(d);
      cb.onchange = async function(){
        const entry = NAME_TO_ENTRY.get(item.path);
        if(cb.checked){
          if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
          else { await addFromPath(item.path); NAME_TO_ENTRY.set(item.path, LAYERS[LAYERS.length-1]); }
        }else{
          if(entry){ entry.visible=false; entry.layer.visible=false; refreshLayerCards(); }
        }
      };
    });
  }
  initServerList();

  document.getElementById("btnLoadSelected").onclick = async function(){
    const cbs = [].slice.call(serverWrap.querySelectorAll('input[type="checkbox"]'));
    const picked = cbs.filter(x=>x.checked).map(x=>x.value);
    if(!picked.length){ await loadAll(cbs); return; }
    for(const p of picked){
      const entry = NAME_TO_ENTRY.get(p);
      if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
      else { await addFromPath(p); NAME_TO_ENTRY.set(p, LAYERS[LAYERS.length-1]); }
    }
  };
  document.getElementById("btnLoadAll").onclick = async function(){
    const cbs = [].slice.call(serverWrap.querySelectorAll('input[type="checkbox"]'));
    await loadAll(cbs);
  };
  async function loadAll(cbs){
    for(const cb of cbs){ cb.checked = true; }
    for(const it of SERVER_ITEMS){
      const entry = NAME_TO_ENTRY.get(it.path);
      if(entry){ entry.visible=true; entry.layer.visible=true; refreshLayerCards(); }
      else { await addFromPath(it.path); NAME_TO_ENTRY.set(it.path, LAYERS[LAYERS.length-1]); }
    }
  }

  /* file locali (accetta anche palette.json ma senza bottoni) */
  document.getElementById("fileInput").addEventListener("change", async function(ev){
    const files = ev.target.files;
    for(let i=0;i<files.length;i++){
      const f = files[i];
      try{
        const txt = await f.text();
        const obj = JSON.parse(txt);
        if(isPaletteObject(obj)){
          mergePalettes(obj); buildPaletteGallery();
          continue;
        }
        const base = f.name.replace(/\.[^.]+$/,"");
        if(obj.type==="Topology"){
          const names = Object.keys(obj.objects||{}); if(!names.length) continue;
          let pick = names[0], maxn=0;
          for(const n of names){ const g=obj.objects[n]; const cnt=(g && g.geometries || []).length; if(cnt>maxn){maxn=cnt; pick=n;} }
          const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
          await addFromGeoJSONObject(geo, base);
        }else{
          await addFromGeoJSONObject(obj, base);
        }
      }catch(e){ console.error("File err:", f.name, e.message); }
    }
    ev.target.value = "";
  });

  /* add layer da path o oggetto */
  async function addFromPath(path){
    const resp = await fetch(path,{cache:"no-store"});
    if(!resp.ok) throw new Error("HTTP "+resp.status);
    const txt = await resp.text();
    const obj = JSON.parse(txt);
    if(obj.type==="Topology"){
      const names = Object.keys(obj.objects||{}); if(!names.length) throw new Error("TopoJSON senza objects");
      let pick = names[0], maxn=0;
      for(const n of names){ const g=obj.objects[n]; const cnt=(g && g.geometries||[]).length; if(cnt>maxn){maxn=cnt; pick=n;} }
      const geo = window.topojsonClient.feature(obj, obj.objects[pick]);
      await addFromGeoJSONObject(geo, path.replace(/^.*[\\/]/,"").replace(/\.[^.]+$/,""));
    }else{
      await addFromGeoJSONObject(obj, path.replace(/^.*[\\/]/,"").replace(/\.[^.]+$/,""));
    }
  }
  async function addFromGeoJSONObject(obj, titleBase){
    if(!(obj && (obj.type==="FeatureCollection" || obj.type==="Feature"))) throw new Error("GeoJSON non valido");
    const blob = new Blob([JSON.stringify(obj)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const layer = new GeoJSONLayer({ url, title:titleBase });
    map.add(layer);
    const entry = { layer, title:titleBase, groupField:null, paletteName:null, opacity:1, override:null, visible:true, fields:[] };
    LAYERS.push(entry);

    layer.when(async function(){
      entry.fields = await sampleFields(layer);
      entry.groupField = pickBestField(entry.fields);
      entry.paletteName = PALETTE_NAMES[0] || null;
      applyPalette(entry);
      refreshLayerCards();
      try{ const ex=await layer.queryExtent(); if(ex.extent) view.goTo(ex.extent.expand(1.05)); }catch(e){}
    });
  }
  async function sampleFields(layer){
    try{
      const q = layer.createQuery(); q.outFields=["*"]; q.returnGeometry=false; q.num=1;
      const r = await layer.queryFeatures(q);
      if(r.features.length){ return Object.keys(r.features[0].attributes||{}); }
    }catch(e){}
    return [];
  }
  function pickBestField(fields){
    const prefs = ["group20","group_nac","Rank20","group","rank"];
    for(const p of prefs){ if(fields.includes(p)) return p; }
    for(const k of fields){ if(!/^(OBJECTID|FID|id)$/i.test(k)) return k; }
    return fields[0]||null;
  }

  /* renderer, apply, per-layer shuffle/reset */
  function buildRenderer(field, palette, override){
    const infos = [];
    for(let i=1;i<=20;i++){
      const inv = 21 - i; // classi grandi -> colore 1
      const hex = (override && override[String(inv)]) || (palette && palette.colors[String(inv)]) || "#cccccc";
      infos.push({
        value:i,
        symbol:{ type:"simple-fill", color:hex, outline:{color:[0,0,0,0], width:0} },
        label:"Classe "+i
      });
    }
    return { type:"unique-value", field, uniqueValueInfos:infos,
      defaultSymbol:{ type:"simple-fill", color:[220,220,220,0], outline:{color:[0,0,0,0], width:0} } };
  }
  function applyPalette(entry){
    if(!entry.groupField || !entry.paletteName) return;
    const pal = PALETTES[entry.paletteName];
    entry.layer.renderer = buildRenderer(entry.groupField, pal, entry.override);
    entry.layer.opacity = entry.opacity || 1;
  }
  function shuffleColors(entry){
    if(!entry.paletteName) return;
    const pal = PALETTES[entry.paletteName];
    const ranks = Array.from({length:20}, (_,i)=>String(i+1));
    const cols = ranks.map(r=>pal.colors[r]);
    for(let k=cols.length-1;k>0;k--){ const j=Math.floor(Math.random()*(k+1)); const t=cols[k]; cols[k]=cols[j]; cols[j]=t; }
    entry.override = {}; ranks.forEach((r,i)=> entry.override[r]=cols[i]);
    applyPalette(entry); updateCardSwatches(entry);
  }
  function resetLayer(entry){
    entry.override = null; applyPalette(entry); updateCardSwatches(entry);
  }

  /* ===== Palette ===== */
  function isPaletteObject(obj){
    if(!obj) return false;
    if(Array.isArray(obj.palettes)) return true;
    const v = Object.values(obj)[0];
    return v && v.colors;
  }
  function mergePalettes(raw){
    const out = {...PALETTES};
    function add(name, colors, links){
      const norm={}; for(let i=1;i<=20;i++){ const k=String(i); norm[k]=colors[k]||colors[i]; }
      if(Object.values(norm).some(v=>!v)) return;
      out[name]={name, colors:norm, links:links||null};
    }
    if(Array.isArray(raw && raw.palettes)){
      raw.palettes.forEach(p=> add(p.name||"Senza nome", p.colors||{}, p.links||null));
    }else if(raw && typeof raw==="object"){
      Object.keys(raw).forEach(name=>{
        const p = raw[name];
        add(name, (p&&p.colors)||{}, p&&p.links);
      });
    }
    PALETTES = out;
    PALETTE_NAMES = Object.keys(out).sort();
  }
  function buildPaletteGallery(){
    const host = document.getElementById("palGallery");
    host.innerHTML = "";
    PALETTE_NAMES.forEach(name=>{
      const p = PALETTES[name];
      const div = document.createElement("div"); div.className="pal-item"; div.title="Applica "+name;
      const title = document.createElement("div"); title.className="pal-title";
      const tleft = document.createElement("div"); tleft.textContent = name;
      const links = document.createElement("div"); links.className="pal-links";
      if(p.links){
        if(p.links.google_images){ const a=document.createElement("a"); a.href=p.links.google_images; a.target="_blank"; a.title="Google Images"; a.textContent="🔍"; links.appendChild(a); }
        if(p.links.wikipedia){ const a2=document.createElement("a"); a2.href=p.links.wikipedia; a2.target="_blank"; a2.title="Wikipedia"; a2.textContent="📖"; links.appendChild(a2); }
        if(p.links.google_arts_culture){ const a3=document.createElement("a"); a3.href=p.links.google_arts_culture; a3.target="_blank"; a3.title="Google Arts & Culture"; a3.textContent="🏛️"; links.appendChild(a3); }
        if(p.links.wikiart){ const a4=document.createElement("a"); a4.href=p.links.wikiart; a4.target="_blank"; a4.title="WikiArt"; a4.textContent="🎨"; links.appendChild(a4); }
      }
      title.appendChild(tleft); title.appendChild(links);

      const sw1 = document.createElement("div"); sw1.className="sw-row";
      const sw2 = document.createElement("div"); sw2.className="sw-row";
      for(let i=1;i<=10;i++){ const c=document.createElement("div"); c.className="sw"; c.style.background=p.colors[String(i)]; sw1.appendChild(c); }
      for(let j=11;j<=20;j++){ const c=document.createElement("div"); c.className="sw"; c.style.background=p.colors[String(j)]; sw2.appendChild(c); }

      div.appendChild(title); div.appendChild(sw1); div.appendChild(sw2);

      /* click = applica SUBITO:
         - se esistono layer selezionati nella UI (checkbox "Sel") applica solo a quelli
         - altrimenti a tutti i layer VISIBILI
      */
      div.onclick = function(){
        const targets = LAYERS.filter((e,idx)=>{
          const chk = document.getElementById("sel-"+idx);
          return chk && chk.checked;
        });
        const dest = targets.length ? targets : LAYERS.filter(e=>e.visible);
        dest.forEach(e=>{ e.paletteName = name; e.override=null; applyPalette(e); updateCardSwatches(e); });
        refreshLayerCards();
      };

      host.appendChild(div);
    });
  }

  /* layer cards */
  const layersWrap = document.getElementById("layersWrap");
  function refreshLayerCards(){
    layersWrap.innerHTML = "";
    LAYERS.forEach((entry, idx)=>{
      const card = document.createElement("div"); card.className="card";
      const h = document.createElement("h5"); h.textContent = entry.title;
      card.appendChild(h);

      /* riga 1: selezione / visibile / opacità */
      const r1 = document.createElement("div"); r1.className="row";
      r1.innerHTML =
        "<label class='muted'>Sel</label><input type='checkbox' id='sel-"+idx+"'>" +
        "<label class='muted' style='margin-left:8px'>Vis</label><input type='checkbox' id='vis-"+idx+"' "+(entry.visible?"checked":"")+">" +
        "<label class='muted' style='margin-left:8px'>Opacità</label><input type='range' id='op-"+idx+"' min='0' max='1' step='0.05' value='"+(entry.opacity||1)+"' class='grow'>";
      card.appendChild(r1);

      /* riga 2: campo legenda + palette per-layer */
      const r2 = document.createElement("div"); r2.className="row";
      const selField = document.createElement("select"); selField.id = "gf-"+idx; selField.className="grow";
      // priorità: group20, group_nac, poi tutti
      const ordered = orderFields(entry.fields);
      ordered.forEach(f=>{
        const opt = document.createElement("option"); opt.value=f; opt.textContent=f;
        selField.appendChild(opt);
      });
      if(entry.groupField) selField.value = entry.groupField;
      const selPal = document.createElement("select"); selPal.id="pal-"+idx; selPal.style.minWidth="140px";
      PALETTE_NAMES.forEach(n=>{ const o=document.createElement("option"); o.value=n; o.textContent=n; selPal.appendChild(o); });
      if(entry.paletteName) selPal.value = entry.paletteName;

      r2.appendChild(labelSmall("Campo")); r2.appendChild(selField);
      r2.appendChild(labelSmall("Palette")); r2.appendChild(selPal);
      card.appendChild(r2);

      /* riga 3: azioni piccole */
      const r3 = document.createElement("div"); r3.className="chips";
      const b1 = chipBtn("🎲 Shuffle"); const b2 = chipBtn("Reset"); const b3 = chipBtn("Rimuovi");
      r3.appendChild(b1); r3.appendChild(b2); r3.appendChild(b3);
      const swLine = document.createElement("div"); swLine.id="sw-"+idx; swLine.className="row"; swLine.style.marginTop="6px";
      card.appendChild(r3); card.appendChild(swLine);

      layersWrap.appendChild(card);

      // wire
      document.getElementById("vis-"+idx).onchange = function(){ entry.visible=this.checked; entry.layer.visible=this.checked; };
      document.getElementById("op-"+idx).oninput = function(){ entry.opacity=Number(this.value); entry.layer.opacity=entry.opacity; };
      selField.onchange = function(){ entry.groupField=this.value; applyPalette(entry); updateCardSwatches(entry); };
      selPal.onchange   = function(){ entry.paletteName=this.value; entry.override=null; applyPalette(entry); updateCardSwatches(entry); };
      b1.onclick = function(){ shuffleColors(entry); };
      b2.onclick = function(){ resetLayer(entry); };
      b3.onclick = function(){
        map.remove(entry.layer);
        const k = LAYERS.indexOf(entry); if(k>=0) LAYERS.splice(k,1);
        refreshLayerCards();
      };

      updateCardSwatches(entry);
    });
  }
  function labelSmall(txt){ const l=document.createElement("label"); l.className="muted"; l.textContent=txt; return l; }
  function chipBtn(txt){ const b=document.createElement("button"); b.className="chip"; b.textContent=txt; return b; }
  function orderFields(arr){
    const pref = ["group20","group_nac","Rank20","group","rank"];
    const set = new Set(arr||[]);
    const out = [];
    pref.forEach(p=>{ if(set.has(p)) out.push(p); });
    arr.forEach(k=>{ if(!out.includes(k)) out.push(k); });
    return out;
  }
  function updateCardSwatches(entry){
    const idx = LAYERS.indexOf(entry);
    const host = document.getElementById("sw-"+idx); if(!host) return;
    host.innerHTML = "";
    if(!entry.paletteName){ host.textContent=""; return; }
    const pal = entry.override ? {colors:entry.override} : PALETTES[entry.paletteName];
    const frag = document.createDocumentFragment();
    for(let i=1;i<=20;i++){
      const s=document.createElement("span");
      s.style.cssText="display:inline-block;width:10px;height:10px;border:1px solid #ccc;margin-left:2px;background:"+pal.colors[String(i)]+";vertical-align:middle;border-radius:2px";
      frag.appendChild(s);
    }
    host.appendChild(frag);
  }

  /* ===== Init palette ===== */
  (async function(){
    try{
      const r = await fetch(DEFAULT_PALETTE_URL, {cache:"no-store"});
      if(r.ok){
        mergePalettes(await r.json());
        buildPaletteGallery();
      }
    }catch(e){ console.warn("Palette default non caricate:", e.message); }
  })();

}); // require end
</script>
</body>
</html>
