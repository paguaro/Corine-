<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Corine ‚Äì multi dataset & palette</title>
<link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css">
<script src="https://js.arcgis.com/4.33/"></script>
<style>
  html,body,#viewDiv{height:100%;margin:0}
  /* Panel raccoglibile */
  #panelToggle{
    position:absolute;left:12px;top:12px;z-index:30;
    background:#fff;border:0;border-radius:999px;width:42px;height:42px;
    box-shadow:0 2px 8px rgba(0,0,0,.25);cursor:pointer;font-size:18px
  }
  #panel{
    position:absolute;left:12px;top:62px;z-index:29;display:none;
    background:#fff;padding:12px;border-radius:10px;box-shadow:0 2px 12px rgba(0,0,0,.2);
    font-family:system-ui,sans-serif;font-size:14px;max-width:520px;max-height:80vh;overflow:auto
  }
  .row{display:flex;gap:8px;align-items:center;margin:.35rem 0}
  .col{display:flex;flex-direction:column;gap:6px}
  .grow{flex:1}
  .card{border:1px solid #e5e7eb;border-radius:8px;background:#fafafa;padding:8px;margin-top:8px}
  .card h4{margin:.2rem 0 .5rem 0;font-size:14px}
  .muted{color:#666}
  .ok{color:#166534}.err{color:#b91c1c}
  button,select,input{font:inherit}
  input[type="range"]{width:100%}
  #log{font-size:12px;max-height:140px;overflow:auto;margin-top:6px;border-top:1px solid #eee;padding-top:6px}

  /* Palette cards */
  #palettesGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  .palCard{border:1px solid #e5e7eb;border-radius:8px;padding:8px;background:#fff;cursor:pointer}
  .palCard:hover{box-shadow:0 2px 10px rgba(0,0,0,.1)}
  .palName{font-weight:600;margin-bottom:6px}
  .swatchGrid{display:grid;grid-template-columns:repeat(10,12px);gap:2px}
  .sw{width:12px;height:12px;border-radius:2px;border:1px solid rgba(0,0,0,.08)}

  /* Basemap picker custom, in basso a destra, richiudibile */
  #bm-toggle{
    position:absolute;right:15px;bottom:15px;z-index:25;
    width:40px;height:40px;border-radius:999px;border:none;
    background:#ffffff; box-shadow:0 2px 8px rgba(0,0,0,.25); cursor:pointer;
    display:flex;align-items:center;justify-content:center;font-size:18px
  }
  #bm-panel{
    position:absolute;right:15px;bottom:65px;z-index:24;display:none;
    background:#fff;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,.25);
    padding:8px;min-width:220px
  }
  #bm-panel label{display:block;font-size:12px;color:#555;margin-bottom:4px}
</style>
</head>
<body>
<div id="viewDiv"></div>

<!-- Toggle pannello -->
<button id="panelToggle" title="Mostra/Nascondi pannello">‚ò∞</button>
<div id="panel">
  <div class="col">
    <div><strong>Dati GeoJSON</strong></div>
    <div class="row">
      <button id="btnLoadDefault" title="Carica dal repo (raw GitHub)">Carica default</button>
      <input id="urlInput" class="grow" type="text" placeholder="./file.geojson o URL raw">
      <button id="btnAddUrl">Aggiungi URL</button>
    </div>
    <div class="row">
      <input id="fileInput" class="grow" type="file" accept=".geojson" multiple>
      <span class="muted">oppure file locale</span>
    </div>
  </div>

  <hr>
  <div class="col">
    <div><strong>Palette (da <code>palettes_from_twb.json</code>)</strong></div>
    <div id="palInfo" class="muted"></div>
    <div id="palettesGrid"></div>
  </div>

  <hr>
  <div class="col">
    <div><strong>Layer caricati</strong></div>
    <div id="layersWrap"></div>
  </div>

  <div id="log"></div>
</div>

<!-- Basemap picker -->
<button id="bm-toggle" title="Basemap">üó∫Ô∏è</button>
<div id="bm-panel">
  <label>Seleziona mappa di base</label>
  <select id="bm-select">
    <option value="gray-vector">Grigio (vector)</option>
    <option value="topo-vector">Topografica (vector)</option>
    <option value="streets-vector">Strade (vector)</option>
    <option value="satellite">Satellite</option>
    <option value="hybrid">Ibrida</option>
    <option value="oceans">Oceani</option>
    <option value="dark-gray-vector">Grigio scuro (vector)</option>
    <option value="terrain">Terreno</option>
    <option value="osm-standard">OSM Standard</option>
  </select>
</div>

<script>
require([
  "esri/Map","esri/views/MapView","esri/layers/GeoJSONLayer",
  "esri/geometry/geometryEngine"
],(Map,MapView,GeoJSONLayer,geometryEngine)=>{

  // --- MAPPA ---
  const map = new Map({ basemap:"gray-vector" });
  const view = new MapView({ container:"viewDiv", map, center:[-8,39.5], zoom:6 });
  view.ui.move("zoom","top-right");

  // --- PANEL TOGGLE ---
  const panel = document.getElementById("panel");
  document.getElementById("panelToggle").onclick=()=>{
    panel.style.display = (panel.style.display==="none"||!panel.style.display) ? "block" : "none";
  };

  // --- BASEMAP PICKER ---
  const btnBM = document.getElementById("bm-toggle");
  const pnlBM = document.getElementById("bm-panel");
  const selBM = document.getElementById("bm-select");
  btnBM.addEventListener("click", ()=>{ pnlBM.style.display = (pnlBM.style.display==="none"||!pnlBM.style.display) ? "block" : "none"; });
  selBM.addEventListener("change", ()=>{ map.basemap = selBM.value; });

  // --- LOG ---
  const log = (msg,cls="")=>{
    const div=document.getElementById("log");
    const el=document.createElement("div"); if(cls) el.className=cls;
    el.textContent=msg; div.appendChild(el); div.scrollTop=div.scrollHeight;
  };

  // --- PALETTE ---
  const FALLBACK = {
    "1":"#a35a16","2":"#7d3f10","3":"#f1b837","4":"#312914","5":"#805835",
    "6":"#d3b04c","7":"#2e110d","8":"#cd6b14","9":"#6a6548","10":"#7f6d2d",
    "11":"#644600","12":"#52461e","13":"#e39226","14":"#973613","15":"#6c2415",
    "16":"#ffdf5a","17":"#0f0506","18":"#a58936","19":"#606d35","20":"#4d2212"
  };
  // Sempre una palette valida disponibile
  let PALETTES = { "Default": { name:"Default", colors:{...FALLBACK} } };
  let activePaletteName = "Default";

  function normalizePalettes(obj){
    const out={};
    if(Array.isArray(obj?.palettes)){
      obj.palettes.forEach(p=>{
        const name=p.name||"Senza nome";
        const colors={}; for(let i=1;i<=20;i++) colors[String(i)] = p.colors?.[String(i)] || FALLBACK[String(i)];
        out[name]={name,colors};
      });
    }else{
      Object.entries(obj||{}).forEach(([name,p])=>{
        if(!p?.colors) return;
        const colors={}; for(let i=1;i<=20;i++) colors[String(i)] = p.colors?.[String(i)] || FALLBACK[String(i)];
        out[name]={name,colors};
      });
    }
    return out;
  }

  async function autoLoadPalettes(){
    const palInfo=document.getElementById("palInfo");
    try{
      const r=await fetch("./palettes_from_twb.json",{cache:"no-store"});
      if(!r.ok) throw new Error("404 palettes_from_twb.json");
      const data=await r.json();
      const norm=normalizePalettes(data);
      // mantieni Default + aggiungi le altre
      PALETTES = { ...PALETTES, ...norm };
      // se la palette attiva non esiste nelle nuove, scegli la prima disponibile
      if(!PALETTES[activePaletteName]){
        const first=Object.keys(PALETTES)[0]; if(first) activePaletteName=first;
      }
      palInfo.textContent=`Palette caricate: ${Object.keys(PALETTES).length}`;
      renderPaletteCards();
      applyPaletteToAll(); // re-render quando arrivano
    }catch(e){
      renderPaletteCards();
      log("Palette non trovate in root: uso solo 'Default'.","err");
    }
  }

  function renderPaletteCards(){
    const grid=document.getElementById("palettesGrid");
    grid.innerHTML="";
    Object.values(PALETTES).forEach(p=>{
      const card=document.createElement("div"); card.className="palCard";
      const name=document.createElement("div"); name.className="palName"; name.textContent=p.name;
      const swGrid=document.createElement("div"); swGrid.className="swatchGrid";
      for(let i=1;i<=20;i++){
        const sw=document.createElement("div"); sw.className="sw";
        sw.style.background = p.colors[String(i)] || "#ccc";
        swGrid.appendChild(sw);
      }
      card.appendChild(name); card.appendChild(swGrid);
      card.onclick=()=>{ activePaletteName=p.name; applyPaletteToAll(); };
      grid.appendChild(card);
    });
  }

  // --- LAYERS & RENDERING ---
  // entry: { layer, title, groupField, paletteName, override:Object, opacity:number, rankOrder:Array }
  const LAYERS=[];

  function isGeoJSON(o){ return o && ((o.type==="FeatureCollection"&&Array.isArray(o.features))||(o.type==="Feature"&&o.geometry)); }

  async function detectGroupField(layer){
    const prefs=["group_20","group","Group","Group20","class","CLASS","clc2012","CLC2012","group_id","Group_ID"];
    try{
      const q=layer.createQuery(); q.outFields=["*"]; q.returnGeometry=false; q.num=1;
      const r=await layer.queryFeatures(q);
      if(r.features.length){
        const attrs=r.features[0].attributes;
        for(const k of prefs){ if(k in attrs) return k; }
        const keys=Object.keys(attrs); return keys.find(k=>k!=="OBJECTID"&&k!=="FID")||keys[0]||null;
      }
    }catch{}
    return null;
  }

  // Calcola ranking per "frequenza + area" usando OGGETTI (niente Map)
  async function computeRankAreaFreq(entry){
    const layer = entry.layer;
    const gf = entry.groupField;
    if(!gf) return null;

    const q = layer.createQuery();
    q.returnGeometry = true;
    q.outFields = [gf];
    q.where = "1=1";
    q.outSpatialReference = { wkid: 4326 };

    const res = await layer.queryFeatures(q);

    const areaBy = Object.create(null);
    const countBy = Object.create(null);

    for(const f of res.features){
      const gid = String(f.attributes[gf]);
      let a = 0;
      try{
        a = Math.abs(geometryEngine.geodesicArea(f.geometry,"square-meters")) || 0;
        if(!isFinite(a) || a < 0) a = 0;
      }catch{
        a = 0;
      }
      areaBy[gid]  = (areaBy[gid]  || 0) + a;
      countBy[gid] = (countBy[gid] || 0) + 1;
    }

    const gids = Object.keys(areaBy);
    if(!gids.length) return { ranks:null, order:null };

    const aMax = Math.max(1, ...gids.map(g=>areaBy[g]||0));
    const cMax = Math.max(1, ...gids.map(g=>countBy[g]||0));

    // score = area_norm + count_norm
    const scored = gids.map(g => [g, (areaBy[g]/aMax) + (countBy[g]/cMax)]);
    scored.sort((a,b)=> b[1]-a[1]);

    const order = scored.map(([g])=>g); // gid in ordine discendente
    return { ranks:null, order };
  }

  // override √® oggetto {"1":"#hex",...}
  function getOverrideColor(override, rank){ return override ? (override[rank]||override[String(rank)]||null) : null; }

  function toSameTypeValue(sampleFieldValue, gidStr){
    const n = Number(gidStr);
    return (typeof sampleFieldValue === "number" && !Number.isNaN(n)) ? n : gidStr;
  }

  function buildRenderer(field, palette, override, rankOrder, sampleFieldValue){
    const uvInfos = [];
    if (Array.isArray(rankOrder) && rankOrder.length){
      // palette 20..1 (pi√π grande = colore 20)
      const paletteKeys = Array.from({length:20},(_,i)=>String(i+1));
      const ascColors = paletteKeys.map(k=>palette.colors[k]);
      const descColors = ascColors.slice().reverse(); // [20..1]

      rankOrder.forEach((gid, idx)=>{
        const valueForField = toSameTypeValue(sampleFieldValue, gid);
        const hex = idx < 20
          ? (getOverrideColor(override, String(20-idx)) || descColors[idx])
          : "#cccccc";
        uvInfos.push({
          value: valueForField,
          symbol: { type:"simple-fill", color: hex, outline:{ color:[0,0,0,0], width:0 } },
          label: `Gruppo ${gid}`
        });
      });
    }else{
      // fallback: mappa rank 1..20 direttamente (per campi gi√† 1..20)
      for(let i=1;i<=20;i++){
        const rank=String(i);
        const hex = getOverrideColor(override,rank) || palette.colors[rank] || "#cccccc";
        uvInfos.push({
          value: Number.isNaN(Number(rank)) ? rank : Number(rank),
          symbol: { type:"simple-fill", color: hex, outline:{ color:[0,0,0,0], width:0 } },
          label: `Classe ${rank}`
        });
      }
    }

    return {
      type:"unique-value",
      field,
      uniqueValueInfos: uvInfos,
      defaultSymbol:{ type:"simple-fill", color:[220,220,220,0], outline:{ color:[0,0,0,0], width:0 } }
    };
  }

  async function sampleFieldValue(layer, field){
    try{
      const q=layer.createQuery(); q.outFields=[field]; q.returnGeometry=false; q.num=1;
      const r=await layer.queryFeatures(q);
      return r.features[0]?.attributes?.[field];
    }catch{ return null; }
  }

  async function applyPalette(entry, recalc=false){
    // scegli una palette valida in ogni caso
    const pal =
      (entry.paletteName && PALETTES[entry.paletteName]) ||
      (PALETTES[activePaletteName]) ||
      (PALETTES["Default"]) ||
      { name:"Fallback", colors:{...FALLBACK} };

    if(!entry.groupField){ log(`${entry.title}: imposta il campo gruppo nella card`,"err"); return; }

    // Se richiesto (o non abbiamo ancora ranking), calcola ranking area+freq
    if(recalc || !entry.rankOrder){
      try{
        const res = await computeRankAreaFreq(entry);
        entry.rankOrder = res?.order || null;
      }catch(e){
        log(`Ranking area+freq fallito: ${e.message}`,"err");
        entry.rankOrder = null;
      }
      // quando ricalcolo, azzero eventuale shuffle
      entry.override = null;
    }

    const sampleVal = await sampleFieldValue(entry.layer, entry.groupField);
    entry.layer.renderer = buildRenderer(entry.groupField, pal, entry.override, entry.rankOrder, sampleVal);
    entry.layer.opacity = entry.opacity ?? 0.7;
  }

  function applyPaletteToAll(recalc=false){
    LAYERS.forEach(e=>{ e.paletteName = activePaletteName; applyPalette(e, recalc); });
    refreshLayerCards();
  }

  function shuffleColors(entry){
    // rimescola i colori 1..20 senza cambiare l‚Äôordine dei gruppi
    const pal = (PALETTES[entry.paletteName] || PALETTES[activePaletteName] || PALETTES["Default"]);
    const ranks = Array.from({length:20},(_,i)=>String(i+1));
    const cols = ranks.map(r=>pal.colors[r]);
    for(let i=cols.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [cols[i],cols[j]]=[cols[j],cols[i]]; }
    entry.override = {};
    ranks.forEach((r,i)=> entry.override[r]=cols[i]);
    applyPalette(entry, false); // re-render immediato, no recalc
  }

  async function addFromURL(url, niceName){
    try{
      const resp=await fetch(url,{cache:"no-store"});
      if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const obj=await resp.json();
      if(!isGeoJSON(obj)) throw new Error("Non √® GeoJSON");
      const blob=new Blob([JSON.stringify(obj)],{type:"application/json"});
      const blobUrl=URL.createObjectURL(blob);
      const layer=new GeoJSONLayer({ url: blobUrl, title: niceName || (url.split("/").pop()||"GeoJSON") });
      map.add(layer);
      const entry={ layer, title:layer.title, groupField:null, paletteName:activePaletteName, override:null, opacity:0.7, rankOrder:null };
      LAYERS.push(entry);
      layer.when(async()=>{
        entry.groupField=await detectGroupField(layer);
        await applyPalette(entry, true); // primo render: calcolo ranking area+freq
        refreshLayerCards();
        try{ const ex=await layer.queryExtent(); if(ex.extent) view.goTo(ex.extent.expand(1.05)); }catch{}
        log(`Caricato: ${url}`,"ok");
      }).catch(e=>log(`Errore layer: ${e.message}`,"err"));
    }catch(e){ log(`Errore URL ${url}: ${e.message}`,"err"); }
  }

  function refreshLayerCards(){
    const wrap=document.getElementById("layersWrap"); wrap.innerHTML="";
    LAYERS.forEach((entry,idx)=>{
      const card=document.createElement("div"); card.className="card";
      card.innerHTML=`
        <h4>${entry.title}</h4>
        <div class="row">
          <label class="muted" style="width:120px">Campo gruppo</label>
          <input id="gf-${idx}" class="grow" type="text" value="${entry.groupField??''}" placeholder="es. group_20">
        </div>
        <div class="row">
          <label class="muted" style="width:120px">Palette</label>
          <select id="pal-${idx}" class="grow"></select>
        </div>
        <div class="row">
          <label class="muted" style="width:120px">Opacit√†</label>
          <input id="op-${idx}" type="range" min="0" max="1" step="0.05" value="${entry.opacity??0.7}">
        </div>
        <div class="row">
          <button id="btnShuffle-${idx}">üé≤ Shuffle</button>
          <button id="btnApply-${idx}" title="Reimposta secondo frequenza+area">Applica</button>
          <button id="btnRemove-${idx}">Rimuovi</button>
        </div>`;
      wrap.appendChild(card);

      // palette list
      const sel=card.querySelector(`#pal-${idx}`); sel.innerHTML="";
      Object.keys(PALETTES).forEach(name=>{
        const opt=document.createElement("option"); opt.value=name; opt.textContent=name;
        if(name===(entry.paletteName||activePaletteName)) opt.selected=true;
        sel.appendChild(opt);
      });

      card.querySelector(`#gf-${idx}`).addEventListener("change", e=>{
        entry.groupField = e.target.value.trim();
      });
      sel.addEventListener("change", e=>{
        entry.paletteName = e.target.value; entry.override=null; applyPalette(entry, false);
      });
      card.querySelector(`#op-${idx}`).addEventListener("input", e=>{
        entry.opacity = Number(e.target.value);
        entry.layer.opacity = entry.opacity;
      });
      card.querySelector(`#btnShuffle-${idx}`).onclick = ()=> shuffleColors(entry);
      card.querySelector(`#btnApply-${idx}`).onclick   = ()=> applyPalette(entry, true);  // ricalcolo ranking area+freq
      card.querySelector(`#btnRemove-${idx}`).onclick  = ()=>{
        map.remove(entry.layer);
        LAYERS.splice(idx,1);
        refreshLayerCards();
      };
    });
  }

  // --- UI DATI ---
  const RAW_DEFAULT = "https://raw.githubusercontent.com/paguaro/Corine-/main/CLC2012_Export_FeaturesToJSO.geojson";
  document.getElementById("btnLoadDefault").onclick=()=> addFromURL(RAW_DEFAULT,"Corine (default)");
  document.getElementById("btnAddUrl").onclick=()=>{
    const u=(document.getElementById("urlInput").value||"").trim();
    if(u) addFromURL(u);
  };
  document.getElementById("fileInput").addEventListener("change", async ev=>{
    for(const f of ev.target.files){
      try{
        const obj=JSON.parse(await f.text());
        if(!isGeoJSON(obj)){ log(`"${f.name}" non √® GeoJSON`,"err"); continue; }
        const url=URL.createObjectURL(new Blob([JSON.stringify(obj)],{type:"application/json"}));
        const layer=new GeoJSONLayer({ url, title:f.name });
        map.add(layer);
        const entry={ layer, title:f.name, groupField:null, paletteName:activePaletteName, override:null, opacity:0.7, rankOrder:null };
        LAYERS.push(entry);
        layer.when(async()=>{
          entry.groupField=await detectGroupField(layer);
          await applyPalette(entry, true);
          refreshLayerCards();
          try{ const ex=await layer.queryExtent(); if(ex.extent) view.goTo(ex.extent.expand(1.05)); }catch{}
          log(`Caricato file: ${f.name}`,"ok");
        });
      }catch(e){ log(`Errore file ${f.name}: ${e.message}`,"err"); }
    }
    ev.target.value="";
  });

  // avvio
  autoLoadPalettes();
  addFromURL(RAW_DEFAULT,"Corine (default)");
});
</script>
</body>
</html>
